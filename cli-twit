#!/usr/bin/ruby

require 'rubygems'
require 'oauth'
require 'json'
require 'net/http'
require 'rake'
require 'io/console'
require 'curses'

class CLItwit
        def initialize(accessfile)
                @accessfile = accessfile
        end

        def datafile_exists
                return File.exists?( @accessfile )
        end

        def get_consumer
                data = Net::HTTP.get( 'julianrutledge.com', '/cli-twit' )
                data_hash = data.split(":")
                @consumer_key = data_hash[0].chomp
                #puts "ck: " + @consumer_key
                @consumer_secret = data_hash[1].chomp
                #puts "ck: " + @consumer_secret
        end


        def authorize
                @consumer = OAuth::Consumer.new(
                        @consumer_key,
                        @consumer_secret,
                        {
                                :site => "https://api.twitter.com",
                                :scheme => :header,
                                :http_method =>:post,
                                :request_token_path => "/oauth/request_token",
                                :access_token_path => "/oauth/access_token",
                                :authorize_path => "/oauth/authorize"
                        }
                )
                @request_token = @consumer.get_request_token

                puts "Please visit the following URL: "
                puts @request_token.authorize_url
                puts "to authorize cli-twit to post on your behalf."
                puts "Enter the authorization PIN to continue, or 'q' to quit:"
                input = gets.chomp
                got_input = false
                if input.downcase == 'q'
                        puts "Exiting without authorizing cli-twit."
                else
                        @access_token = @request_token.get_access_token(
                                :oauth_verifier => input
                        )
                end
        end

        def create_new_datafile
                puts "Welcome to CLI Twit!"
                puts "It seems to be your first time using the software. Let's get set up."
                
                get_consumer()
                authorize()

                File.open( "access", "w" ) { 
                        |line| line.write(@access_token.token + ":" + @access_token.secret) 
                }
        end

        def read_datafile
                access = File.open(@accessfile, "r") 
                access_hash = Hash.new
                access.each { |line| access_hash = line.split(":") }
                access.close
                @token = access_hash[0].chomp
                @secret = access_hash[1].chomp
        end

        def cat_data
                puts @token
                puts @secret
        end

        def get_all_credentials
                get_consumer()  # get the consumer credentials from home
                @api = OAuth::Consumer.new(@consumer_key, @consumer_secret)
                read_datafile() # read the access token from local file
                @access = OAuth::Token.new(@token, @secret)
        end

        def feed_pretty( feed_hash )
                #FEED ME HASH!
                #wait... no.
                #FEED ME _A_ HASH!
                bar = print_bar( @columns - 2, "-" )
		pretty_output = []
                feed_hash.each { |tweet| # include tweet_id for replies
                        #make this a bit more readable
                        user = tweet[1][0]
                        #remove trailing hyperlink
                        text_array = tweet[1][1].split("http")
                        text = text_array[0].sub("\n"," ")
                        #remove newlines
                        text = text.sub("\n"," ")
                        #remove carriage returns
                        text = text.sub("\r"," ")
                        #remove ampersands
                        text = text.sub("&amp;","&")
                        #remove "greater than"
                        text = text.sub("&gt;",">")
                        #remove "less than"
                        text = text.sub("&lt;","<")

                        tweet_id = tweet[1][2]
                        link_hash = tweet[1][3]
                        screen_name = tweet[1][4]
                        num_favs = tweet[1][5]
                        num_retw = tweet[1][6]
                        date = tweet[1][7]

                        #count the username and create the tabspace until the text
                        pretty_output << "    #{user} @#{screen_name}"
                        pretty_output << "    " + text
                        pretty_output << ""
                        #dealing with PITA urls
                        if link_hash != nil
                                link = link_hash["expanded_url"]
                                if link.length > 50
                                        link = link_hash["url"]
                                        pretty_output << "    link: #{link}"
                                else
                                        pretty_output << "    link: #{link}"
                                end
                        elsif "#{text_array[1]}".length > 1
                                pretty_output << "    link: http#{text_array[1]}"
                        end
			pretty_output << "    ........................."
                        pretty_output << "    tweet id: #{tweet_id}"
                        pretty_output << "    retweets: #{num_retw}"
                        pretty_output << "    favorites: #{num_favs}"
                        pretty_output << "    date posted: #{date}"
                        pretty_output << bar
                }
		return pretty_output
        end

        def api_call( http_method, api_path, query_opts )
                #using a query here is a more uniform method than request.set_form_data for POST
                if query_opts != nil
                        query = URI.encode_www_form(query_opts)
                        @query = "?#{query}"
                else
                        @query = ""
                end

                @base_url = "https://api.twitter.com"
                @path = api_path
                @address = URI("#{@base_url}#{@path}#{@query}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                if http_method == :get
                        @request = Net::HTTP::Get.new(@address.request_uri)
                elsif http_method == :post
                        @request = Net::HTTP::Post.new(@address.request_uri)
                end
                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)
        end

        def favorite( favorite_id )
                output = []

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/create.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been favorited: #{tweet["text"]}"
                        else
                                output << "Tweet failed to be favorited: #{@response.body}"
                        end
                else
                        output << "Please pass tweet id as an argument to this function."
                end

                return output
        end

        def unfavorite( favorite_id )
                output = []

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/destroy.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been unfavorited: #{tweet["text"]}"
                        else
                                output << "Tweet failed to be unfavorited: #{@response.body}"
                        end
                else
                        output << "Please pass tweet id as an argument to this function."
                end

                return output
        end

 
        def get_home_timeline( num_tweets )
                api_call( :get, "/1.1/statuses/home_timeline.json", {"count" => num_tweets} )

                feed = nil
                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        #puts feed
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date ]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty( output )
                else
                        return ["Could not get the feed! Code:#{@response.code} Body:#{@response.body}"]
                end
        end

        def post_tweet( text )
                output = []

                if text != nil and text.length > 140
                        output << "Tweet text is more than 140 characters. Post aborted."
                elsif text != nil and text.length <= 140
                        api_call( :post, "/1.1/statuses/update.json", {"status" => text} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been posted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to post: #{@response.body}"
                        end
                else
                        output << "No tweet text given. Post aborted."
                end

                return output
        end

        def post_reply( username, tweet_id, text )
                output = []

                all_good = true if username != nil and tweet_id != nil and text != nil and username =~ /@/

                if all_good == true
                        tweet_length = username.length + text.length
                        
                        if tweet_length > 140
                                output << "Tweet length more than 140 characters. Reply aborted."
                        else
                                final_text = "#{username} #{text}"
                                api_call( :post, "/1.1/statuses/update.json", {"status" => final_text, "in_reply_to_status_id" => tweet_id} )
                                
                                if @response.code == '200'
                                        tweet = JSON.parse(@response.body)
                                        output <<  "Tweet has been posted: #{tweet["text"]}"
                                else
                                        output << "Tweet failed to post: #{@response.body}"
                                end
                        end
                else
                        output << "Please check your parameters. See help function for more info."
                end

                return output
        end

        def retweet( tweet_id )
                output = []

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/retweet/#{tweet_id}.json", {} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been posted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to post: #{@response.body}"
                        end
                else
                        output << "Tweet id empty. Retweeting aborted."
                end

                return output
        end

        def delete_post( tweet_id )
                output = []

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/destroy.json", { "id" => tweet_id } )
                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet ##{tweet["id_str"]} has been deleted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to delete: #{@response.body}"
                        end
                else
                        output << "No tweet ID given; deletion aborted."
                end

                return output
        end

        def follow_user( username )
                output = []

                if username != nil
                        api_call( :post, "/1.1/friendships/create.json", { "screen_name" => username, "follow" => true } )
                        if @response.code == '200'
                                confirm = JSON.parse(@response.body)
                                user_followed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output << "Now following user #{user_followed}: #{real_name}"
                        else
                                output << "Failed to follow user: #{@response.body}"
                        end
                else
                        output << "Follow failed; username cannot be empty."
                end

                return output
        end

        def unfollow_user( username )
                output = []

                if username != nil
                        api_call( :post, "/1.1/friendships/destroy.json", { "screen_name" => username } )
                        if @response.code == '200' then
                                confirm = JSON.parse(@response.body)
                                user_unfollowed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output <<  "Unfollowed user #{user_unfollowed}: #{real_name}"
                        else
                                output << "Failed to follow user: #{@response.body}"
                        end
                else
                        output << "Unfollow failed; username cannot be empty."
                end

                return output
         end

         def get_user_feed( username, num_tweets )
                api_call( :get, "/1.1/statuses/user_timeline.json", { "screen_name" => username, "count" => num_tweets } )

                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty( output )
               else
                        return "Could not get the feed!" +
                        "Code:#{@response.code} Body:#{@response.body}"
               end
        end

        def header
                header = []
                header << "       ________   ____      ___      __________ "
                header << "      /       /  /   /     /   /    /         /           __"
                header << "     /   ____/  /   /     /   /    /___   ___/           /_/   __"
                header << "    /   /      /   /     /   / ____   /  /   __     __  _   __/ /_"
                header << "   /   /      /   /     /   / /___/  /  /   / / _  / / / / /_  __/"
                header << "  /   /____  /   /___  /   /        /  /   / / // / / / /   / /"
                header << " /        / /       / /   /        /  /   / /_//_/ / / /   / /"
                header << "/________/ /_______/ /___/        /__/   /________/ /_/   /_/"

                return header
        end

        def print_bar( num, type )
                bar = ""
                num.times { bar << type }
                return bar
        end

        def help
                help = []
                help << "Command syntax:"
                help << "  <command> <parameter1> <parameter2> <etc...>"
                help << "  Parameters marked |M| are mandatory;"
                help << "  parameters marked |O| are optional."
                help << ""
                help << "Command List:"
                help << "  'home' or 'h'\tView your home feed"
                help << "\t\t\t<command> <|O|number>"
                help << ""
                help << "  'post' or 'p'\tWrite a post"
                help << "\t\t\t<command> <|M|text>"
                help << ""
                help << "  'reply' or 'rp'\tReply to a tweet"
                help << "\t\t\t<command> @<|M|username> <|M|tweet_id> <|M|text>"
                help << ""
                help << "  'retweet' or 'rt'\tRetweet a tweet"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'user' or 'u'\tView another user's feed"
                help << "\t\t\t<command> <|M|username> <|O|number>"
                help << ""
                help << "  'fav' or 'f'   \tMark a post as favorite"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'unfav' or 'uf'\tUnmark a post as favorite"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'follow' or 'fo'\tFollow a user"
                help << "\t\t\t<command> @<|M|username>"
                help << ""
                help << "  'unfolow' or 'ufo'\tUnfollow a user"
                help << "\t\t\t<command> @<|M|username>"
                help << ""
                help << "  'delete' or 'd'\tDelete a tweet (must be your own)"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'help' or '?'\tView this help menu"
                help << ""
                help << "  'quit' or 'q'\tExit the program"
                help << ""
                return help
        end

	def center_pos(rows,columns)
		row_center = (rows.to_f/2).floor
		col_center = (columns.to_f/2).floor
		return row_center, col_center
	end

	def draw_window
                #######################################
                #    I AM THE MASTER OUTPUT METHOD!   #
                #  NO ONE SHOULD DRAW WINDOWS BUT ME  #
                #######################################

                #determine screen size here.
                #this is the first, last, and only place this will be decided.
                #if the user resizes the terminal after this,
                #it will fuck everything up.
		@rows, @columns = $stdin.winsize
                
                #draw our window and set echo off
                #all other methods will clear and redraw this window
                Curses.noecho
                
                #enable keypad - necessary for pageup/pagedown & direction buttons
                Curses.stdscr.keypad( true )
                @screen = Curses::Window.new(@rows,@columns,0,0)
                @screen.box('|','-','#')
        end

        def populate_window( input )
                ################################################################
                #  I AM THE METHOD THAT POPULATES THE MASTER WINDOW WITH DATA  #
                #               I CLEAR THE MASTER AND WRITE OUTPUT            #
                ################################################################

                #clear anything that was written to the screen before this
                @screen.clear

                #declare line incrementor for output
                @i = 1

                ##########
                # HEADER #
                ##########
                
                #draw the cli-twit header
                head = header()
                head.each do |line|
                        @screen.setpos(@i,1)
                        @screen.addstr( line )
                        @i += 1
                end

                #################
                # NOTIFICATIONS #
                #################
                
                #draw the bar
                @screen.setpos(@i,1)
                bar_length = @columns - 2
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i += 1
                #TODO: make status bar here for private messages and notifications
                @screen.setpos(@i,1)
                @screen.addstr( "NOTIFICATION BAR" )
                @i += 1
                #draw the bar again and make it change depending on whether the input continues beyond the bar
                @screen.setpos(@i,1)
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i += 1
                #the bottom of the notification bar will be drawn as the top of the info panel

                #####################
                # INFORMATION PANEL #
                #####################
                
                #set the max amount of rows of information allowed
                #in the window based on number of rows in the terminal,
                #header hight, the notification bar, and the space needed
                #at the bottom for command entry.
                #defining this here will allow us to scroll through the 
                #info panel with the arrow keys later
                header_size = head.length
                notification_bar_size = 3
                command_bar_size  = 3
                @info_panel_size = @rows - header_size - notification_bar_size - command_bar_size - 1
                #i don't know why this needs an extra row removed, but fuck it - it works

                #if the input has fewer rows than the info panel, and blank rows to fill the panel
                if input.length < @info_panel_size
                        num_blank_rows = @info_panel_size - input.length
                        num_blank_rows.times do
                                input << ""
                        end
                #if the amount of input is greater than the info panel size, chop that shit to fit!
                #considering the input, this is very likely unless the user specifies  a small amount.
                elsif input.length > @info_panel_size
                        input = input[0..( @info_panel_size - 1 )]
                end

                #display text output
                @screen.setpos(@i,1)
                input.each do |line|
                        @screen.setpos(@i,1)
                        @screen.addstr(line)
                        @i += 1
                end
                @screen.setpos(@i,1)

                #################
                # COMMAND PANEL #
                #################

                #draw the bar
                @screen.setpos(@i,1)
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i += 1
                @screen.setpos(@i,1)
                #this mind intentionally left blank
                @screen.addstr( "" )
                @i += 1
                #draw the bar again
                @screen.setpos(@i,1)
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i -= 1
                @screen.setpos(@i,1)
        end

        def read_input
                loop do 
                        input = @screen.getch

                        case input

                        when ':'
                                get_command()
                        when 'k'
                                scroll_up()
                        when 'j'
                                scroll_down()
                        end
                end
        end

        def scroll_up
                @text_begin -= 1 if @text_begin > 0
                populate_window( @text_output[@text_begin..-1] )
                read_input()
        end

        def scroll_down()
                @text_begin += 1 if @text_begin <= @text_end - @info_panel_size
                populate_window( @text_output[@text_begin..-1] )
                read_input()
        end

        def process_command( command, params )
                #output command expects an array
                #declare it here so we can get it later
                text_output = Array.new

                #maybe we should sanitize our parameter first before blindly passing it to the following functions
                #:: code goes here
                #nah, fuck it.
                
                case command
                when nil
                        #do nothing. this allows us to bail on a command and stay on the same screen. 
                when /^home$/, /^h$/
                        tweets = params[0]
                        tweets = 20 if tweets == nil
                        @text_output = get_home_timeline( tweets )
                when /^post$/, /^p$/
                        @text_output = post_tweet( params.join(" ") )
                when /^reply$/, /^rp$/
                        name = params[0]
                        id = params[1]
                        text = params[2..-1].join(" ")
                        @text_output = post_reply( name, id, text )
                when /^retweet$/, /^rt$/
                        @text_output = retweet( params[0] )
                when /^user$/, /^u$/
                        user, tweets = params
                        tweets = 20 if tweets == nil
                        @text_output = get_user_feed( user, tweets )
                when /^fav$/, /^f$/
                        @text_output =  favorite( params[0] )
                when /^unfav$/, /^uf$/
                        @text_output = unfavorite( params[0] )
                when /^follow$/, /^fo$/
                        @text_output = follow_user( params[0] )
                when /unfollow$/, /^ufo$/
                        @text_output = unfollow_user( params[0] )
                when /^delete$/, /^d$/
                        @text_output = delete_post( params[0] )
                when/^help$/, /^\?$/
                        @text_output = help()
                when /^quit$/, /^q$/, /^exit$/
			exit
                else
                        @text_output = [ "Unrecognized command: \'#{command}\'" ]
                end

                #burger's done
                @text_end = @text_output.length
                populate_window( @text_output )
                read_input()
        end
        
	def get_command
                @screen.addstr(":")
                Curses.echo
                input = @screen.getstr
                command = input.split(" ")[0]
                params = input.split(" ")[1..-1]#this returns an array
                Curses.noecho
                
                #reset this every time a new command is issued. 
                @text_begin = 0
                
                #this is where the snake eats its tail:
                #we loop back on ourselves here.
                process_command( command, params )
	end

        def begin
                if datafile_exists() == false
                        create_new_datafile() # both consumer info and access token are gathered in this step
                end


                #check screen size here first before we launch.
                #this will be checks again when the output screen is drawn.
		rows, columns = $stdin.winsize
                if rows > 22 and columns > 66
                        #this is where we draw our screen, draw our screen, draw our screen;
                        #this is where we draw our screen - all day long.
                        draw_window
                        #first data
                        @text_output = [ "Press ':' to enter a command" ]
                        @text_begin = 0
                        @text_end = @text_output.length
                        populate_window( @text_output )
                        read_input()
                        
		else
			puts `clear`
			puts "The terminal size is too small."
			puts "The terminal must be"
			puts "at least 22 characters tall"
			puts "and 66 characters wide."
			puts "Please resize and run again."
			exit
		end
        end
end

session = CLItwit.new( "access" )
session.begin

