#!/usr/bin/ruby

require 'rubygems'
require 'oauth'
require 'json'
require 'net/http'
require 'rake'

class Twitter
        def initialize(accessfile)
                @accessfile = accessfile
        end

        def datafile_exists
                return File.exists?(@accessfile)
        end

        def get_consumer
                data = Net::HTTP.get( 'julianrutledge.com', '/cli-twit' )
                data_hash = data.split(":")
                @consumer_key = data_hash[0].chomp
                #puts "ck: " + @consumer_key
                @consumer_secret = data_hash[1].chomp
                #puts "ck: " + @consumer_secret
        end


        def authorize
                @consumer = OAuth::Consumer.new(
                        @consumer_key,
                        @consumer_secret,
                        {
                                :site => "https://api.twitter.com",
                                :scheme => :header,
                                :http_method =>:post,
                                :request_token_path => "/oauth/request_token",
                                :access_token_path => "/oauth/access_token",
                                :authorize_path => "/oauth/authorize"
                        }
                )
                @request_token = @consumer.get_request_token

                puts "Please visit the following URL: "
                puts @request_token.authorize_url
                puts "to authorize cli-twit to post on your behalf."
                puts "Enter the authorization PIN to continue, or 'q' to quit:"
                input = gets.chomp
                got_input = false
                if input.downcase == 'q'
                        puts "Exiting without authorizing cli-twit."
                else
                        @access_token = @request_token.get_access_token(
                                :oauth_verifier => input
                        )
                end
        end

        def create_new_datafile
                puts "Welcome to CLI Twit!"
                puts "It seems to be your first time using the software. Let's get set up."
                
                get_consumer()
                authorize()

                File.open("access", "w") { 
                        |line| line.write(@access_token.token + ":" + @access_token.secret) 
                }
        end

        def read_datafile
                access = File.open(@accessfile, "r") 
                access_hash = Hash.new
                access.each { |line| access_hash = line.split(":") }
                access.close
                @token = access_hash[0].chomp
                @secret = access_hash[1].chomp
        end

        def cat_data
                puts @token
                puts @secret
        end

        def get_all_credentials
                get_consumer()  # get the consumer credentials from home
                @api = OAuth::Consumer.new(@consumer_key, @consumer_secret)
                read_datafile() # read the access token from local file
                @access = OAuth::Token.new(@token, @secret)
        end

        def feed_pretty( feed_hash )
                bar = "--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------\n"
                feed_hash.each { |tweet| # include tweet_id for replies
                        #make this a bit more readable
                        user = tweet[1][0]
                        #remove trailing hyperlink
                        text_array = tweet[1][1].split("http")
                        text = text_array[0].sub("\n"," ")
                        #remove newlines
                        text = text.sub("\n"," ")
                        #remove carriage returns
                        text = text.sub("\r"," ")
                        #remove ampersands
                        text = text.sub("&amp;","&")
                        #remove "greater than"
                        text = text.sub("&gt;",">")
                        #remove "less than"
                        text = text.sub("&lt;","<")

                        tweet_id = tweet[1][2]
                        link_hash = tweet[1][3]
                        screen_name = tweet[1][4]
                        num_favs = tweet[1][5]
                        num_retw = tweet[1][6]
                        date = tweet[1][7]

                        #count the username and create the tabspace until the text
                        char_margin = 28
                        user_char_diff = char_margin - user.length
                        sn_char_diff = char_margin - screen_name.length - 1
                        print bar
                        print "    #{user}"
                        user_char_diff.times { print " " }
                        print "| " + text
                        print "\n"
                        print "    @#{screen_name}"
                        sn_char_diff.times { print " " }
                        print "|\n"
                        #dealing with PITA urls
                        if link_hash != nil
                                link = link_hash["expanded_url"]
                                if link.length > 50
                                        link = link_hash["url"]
                                        32.times {print " "}
                                        print "| link: #{link}\n"
                                else
                                        32.times {print " "}
                                        print "| link: #{link}\n"
                                end
                        elsif "#{text_array[1]}".length > 1
                                32.times {print " "}
                                print "| link: http#{text_array[1]}\n"
                        end
                        32.times {print " "}
                        print "| retweets: #{num_retw}\n"
                        32.times {print " "}
                        print "| favorites: #{num_favs}\n"
                        32.times {print " "}
                        print "| date posted: #{date}\n"
                        32.times {print " "}
                        print "| tweet id: #{tweet_id}\n"
                }
                print bar
        end

        def api_call(http_method, api_path, query_opts)
                #using a query here is a more uniform method than request.set_form_data for POST
                if query_opts != nil
                        query = URI.encode_www_form(query_opts)
                        @query = "?#{query}"
                else
                        @query = ""
                end

                @base_url = "https://api.twitter.com"
                @path = api_path
                @address = URI("#{@base_url}#{@path}#{@query}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                if http_method == :get
                        @request = Net::HTTP::Get.new(@address.request_uri)
                elsif http_method == :post
                        @request = Net::HTTP::Post.new(@address.request_uri)
                end
                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)
        end

        def favorite
                puts "Enter id of the tweet to favorite:"
                print ": "
                favorite_id = gets.chomp
                api_call( :post, "/1.1/favorites/create.json", {"id" => favorite_id} )

                if @response.code == '200'
                        tweet = JSON.parse(@response.body)
                        puts "Tweet has been favorited: " + tweet["text"]
                else
                        puts "Tweet failed to be favorited: "
                        puts "Code: " + @response.code
                        puts "Body: " + @response.body
                end
        end

        def unfavorite
                puts "Enter id of the tweet to unfavorite:"
                print ": "
                favorite_id = gets.chomp
                api_call( :post, "/1.1/favorites/destroy.json", {"id" => favorite_id} )

                if @response.code == '200'
                        tweet = JSON.parse(@response.body)
                        puts "Tweet has been unfavorited: " + tweet["text"]
                else
                        puts "Tweet failed to be unfavorited: "
                        puts "Code: " + @response.code
                        puts "Body: " + @response.body
                end
        end

 
        def get_home_timeline
                api_call( :get, "/1.1/statuses/home_timeline.json", {"count" => 10} )

                feed = nil
                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        #puts feed
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date ]
                                count += 1
                        }

                        #puts output

                        #make our output prettier
                        feed_pretty(output)
                else
                        puts "Could not get the feed!" +
                        "Code:#{@response.code} Body:#{@response.body}"
                end
        end

        def post_tweet(text)
                api_call( :post, "/1.1/statuses/update.json", {"status" => text} )

                if @response.code == '200'
                        tweet = JSON.parse(@response.body)
                        puts "Tweet has been posted: " + tweet["text"]
                else
                        puts "Tweet failed to post: "
                        puts "Code: " + @response.code
                        puts "Body: " + @response.body
                end
        end

        def post_reply(text, username, tweet_id)
                final_text = "#{username} #{text}"
                api_call( :post, "/1.1/statuses/update.json", {"status" => final_text, "in_reply_to_status_id" => tweet_id} )

                if @response.code == '200'
                        tweet = JSON.parse(@response.body)
                        puts "Tweet has been posted: " + tweet["text"]
                else
                        puts "Tweet failed to post: "
                        puts "Code: " + @response.code
                        puts "Body: " + @response.body
                end
        end

        def write_reply
                puts "Enter username to reply to (including '@' symbol):"
                print ": "
                username = gets.chomp
                puts "Enter tweet ID to reply to:"
                print ": "
                tweet_id = gets.chomp
                num_user_chars = username.length
                max_tweet_length = 140 - num_user_chars
                puts "Enter text to post ( must be less than 140 characters ):"
                print ": "
                post_text = gets.chomp
                text = ""

                if post_text.length > max_tweet_length
                        puts "Tweet text more than 140 characters. truncate or abort? (t/a)"
                        print ": "
                        response = gets.chomp.downcase
                        answered = false
                        until answered == true
                                if response == 't'
                                        #truncate post_text to 140 char
                                        text = post_text[0..(max_tweet_length -1)]
                                        post_reply(text, username, tweet_id)
                                        answered = true
                                elsif response == 'a'
                                        #abort post
                                        puts "Tweet aborted."
                                        answered = true
                                else
                                        puts "Not a valid command."
                                        puts "Truncate or abort? (t/a)"
                                        print ": "
                                        response = gets.chomp.downcase
                                end
                        end
                else
                        text = post_text
                        post_reply(text, username, tweet_id)
                end
        end


        def upload_media(path_to_media)
                #query = URI.www_ecode_form( "media" => path_to_media )
                path = "https://upload.twitter.com/1.1/media/upload.json"
                #@address = URI("#{path}?#{query}")
                @address = URI("#{path}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                @request = Net::HTTP::Post.new(@address.request_uri)
                basename = File.basename(path_to_media)

                boundary = "00cli-twit" + rand(100000000000000000).to_s + "tiwt-ilc99"
                multipart_body = []
                filefield = 'media[]'

                multipart_body << "--#{boundary}\r\n"
                #multipart_body << "Content-Disposition: form-data; name=\"#{extension}\"; filename=\"#{basename}\"\r\n"
                multipart_body << "Content-type: application/octet-stream\r\n"
                multipart_body << "\r\n"
                multipart_body << File.read(path_to_media)
                multipart_body << "\r\n--#{boundary}--\r\n"

                @request.body = multipart_body.join

                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)

                if @response.code == '200'
                        puts "Media uploaded sucessfully."
                        upload = JSON.parse(@response.body)
                        @media_id = upload["media_id"]
                else
                        puts "Media upload failed" + "Code: #{@response.code} Body: #{@response.body}"
                end
        end

        def post_media_tweet(text, media_id)
                api_call( :post, "/1.1/statuses/update.json", {"status" => text, "media_ids" => media_id} )

                if @response.code == '200'
                        tweet = JSON.parse(@response.body)
                        puts "Tweet has been posted: " + tweet["text"]
                else
                        puts "Tweet failed to post: "
                        puts "Code: " + @response.code
                        puts "Body: " + @response.body
                end
        end
        
        def write_media_post
                puts "Enter path to media file (JPEG, PNG, and GIF only):"
                print ": "
                path_to_media = gets.chomp

                upload_media(path_to_media)

                if @response == '200'
                        puts "Would you like to say something about this upload? (if not, leave blank)"
                        post_text = gets.chomp
                        text = ""

                        if post_text.length > 140
                                puts "Tweet text more than 140 characters. truncate or abort? (t/a)"
                                print ": "
                                response = gets.chomp.downcase
                                answered = false

                                until answered == true
                                        if response == 't'
                                                text = post_text[0..139]
                                                #post the tweet
                                                post_media_tweet(text, @media_id)
                                                answered = true
                                        elsif response == 'a'
                                                puts "Tweet aborted."
                                                answered == true
                                        else
                                                puts "Not a valid command."
                                                puts "Truncate or abort?"
                                                print ": "
                                                response == gets.chomp.downcase
                                        end
                                end
                        else
                                text = post_text
                                # post the tweet
                                post_media_tweet(text, @media_id)
                        end                                
                else
                        puts "Could not post."
                end
        end

        def retweet
                puts "Enter id of tweet to retweet:"
                print ": "
                tweet_id = gets.chomp
                puts "retweeting tweet: #{tweet_id}"
                api_call( :post, "/1.1/statuses/retweet/#{tweet_id}.json", {} )

                if @response.code == '200'
                        tweet = JSON.parse(@response.body)
                        puts "Tweet has been posted: " + tweet["text"]
                else
                        puts "Tweet failed to post: "
                        puts "Code: " + @response.code
                        puts "Body: " + @response.body
                end
        end

        def delete_post
                puts "Enter id # of tweet to delete (must be your own):"
                print ": " 
                tweet_id = gets.chomp

                puts "are you sure you want to delete tweet ##{tweet_id} (y/n)?"
                answer = gets.chomp.downcase
                answered = false
                until answered == true
                        if answer == 'y'
                                answered = true
                        elsif answer == 'n'
                                answered = true
                        else
                                puts "Not a valid command."
                                puts "are you sure you want to delete tweet ##{tweet_id} (y/n)?"
                                answer = gets.chomp.downcase
                        end
                end

                if answer == 'y'
                        api_call( :post, "/1.1/statuses/destroy.json", {"id" => tweet_id} )
                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                puts "Tweet ##{tweet["id_str"]} has been deleted: " + tweet["text"] 
                        else
                                puts "Tweet failed to delete: "
                                puts "Code: " + @response.code
                                puts "Body: " + @response.body
                        end
                elsif answer == 'n'
                        puts "Deletion aborted."
                end
        end

        def write_post
                puts "Enter text to post ( must be less than 140 characters ):"
                print ": "
                post_text = gets.chomp
                text = ""

                if post_text.length > 140
                        puts "Tweet text more than 140 characters. truncate or abort? (t/a)"
                        print ": "
                        response = gets.chomp.downcase
                        answered = false
                        until answered == true
                                if response == 't'
                                        #truncate post_text to 140 char
                                        text = post_text[0..139]
                                        post_tweet(text)
                                        answered = true
                                elsif response == 'a'
                                        #abort post
                                        puts "Tweet aborted."
                                        answered = true
                                else
                                        puts "Not a valid command."
                                        puts "Truncate or abort? (t/a)"
                                        print ": "
                                        response = gets.chomp.downcase
                                end
                        end
                else
                        text = post_text
                        post_tweet(text)
                end
        end

        def follow_user
                puts "Enter the username to follow:"
                username = gets.chomp
                api_call( :post, "/1.1/friendships/create.json", { "screen_name" => username, "follow" => true })
                if @response.code == '200' then
                        confirm = JSON.parse(@response.body)
                        user_followed = confirm["screen_name"]
                        real_name = confirm["name"]
                        puts "Now following user #{user_followed}:"
                        puts "#{real_name}"
                else
                        puts "Failed to follow user."
                        puts "Code: #{@response.code} Body: #{@response.body}"
                end
         end

        def unfollow_user
                puts "Enter the username to unfollow:"
                username = gets.chomp
                api_call( :post, "/1.1/friendships/destroy.json", { "screen_name" => username })
                if @response.code == '200' then
                        confirm = JSON.parse(@response.body)
                        user_unfollowed = confirm["screen_name"]
                        real_name = confirm["name"]
                        puts "Unfollowed user #{user_unfollowed}:"
                        puts "#{real_name}"
                else
                        puts "Failed to follow user."
                        puts "Code: #{@response.code} Body: #{@response.body}"
                end
         end

         def get_user_feed
                puts "Enter the username to view:"
                username = gets.chomp

                api_call( :get, "/1.1/statuses/user_timeline.json", {"screen_name" => username, "count" => 10 })

                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date]
                                count += 1
                        }

                        #make our output prettier
                        feed_pretty(output)
               else
                        puts "Could not get the feed!" +
                        "Code:#{@response.code} Body:#{@response.body}"
               end
        end

        def welcome_mesg
                #puts "Welcome to CLI-twit, the Command Line Interface for Twitter."
                welcome = "
                      ________   ____      ___      __________ 
                     /       /  /   /     /   /    /         /           __
                    /   ____/  /   /     /   /    /___   ___/           /_/   __
                   /   /      /   /     /   / ____   /  /   __     __  _   __/ /_
                  /   /      /   /     /   / /___/  /  /   / / _  / / / / /_  __/
                 /   /____  /   /___  /   /        /  /   / / // / / / /   / /
                /        / /       / /   /        /  /   / /_//_/ / / /   / /
               /________/ /_______/ /___/        /__/   /________/ /_/   /_/
                
                "
                puts welcome
                puts "Please enter a command:"
        end

        def help
                puts "Command List:"
                puts "  'home' or 'h':"
                puts "      View your home feed"
                puts "  'post' or 'p':"
                puts "      Write a post"
                puts "  'media' or 'mp':"
                puts "      Write a post with media attached"
                puts "  'reply' or 'rp':"
                puts "      Reply to a tweet (requires tweet id)"
                puts "  'retweet' or 'rt':"
                puts "      Retweet a tweet (requires tweet id)"
                puts "  'user' or 'u':"
                puts "      View another user's feed (requires username)"
                puts "  'fav' or 'f':"
                puts "      Mark a post as favorite (requires tweet id)"
                puts "  'unfav' or 'uf':"
                puts "      Unmark a post as favorite (requires tweet id)"
                puts "  'follow' or 'fo':"
                puts "      Follow a user's tweets (requires username)"
                puts "  'unfolow' or 'ufo':"
                puts "      Unfollow a user's tweets (requires username)"
                puts "  'delete' or 'd':"
                puts "      Delete one of your posts (must be your own)"
                puts "  'help' or '?':"
                puts "      View this menu"
                puts "  'quit' or 'q':"
                puts "      Exit the program"
        end


        def begin
                if datafile_exists() == false
                        create_new_datafile() # both consumer info and access token are gathered in this step
                end


                welcome_mesg()

                #main loop
                input = ""
                quit = false
                until quit == true
                        print ": "
                        input = gets.chomp.downcase
                        if input == "home" || input == 'h'
                                get_home_timeline()
                        elsif input == "post" || input == 'p'
                                write_post()
                        elsif input == "media" || input == 'mp'
                                write_media_post()
                        elsif input == "reply" || input == 'rp'
                                write_reply()
                        elsif input == "retweet" || input == 'rt'
                                retweet()
                        elsif input == "user" || input == 'u'
                                get_user_feed()
                        elsif input == "fav" || input == 'f'
                                favorite()
                        elsif input == "unfav" || input == 'uf'
                                unfavorite()
                        elsif input == "follow" || input == 'fo'
                                follow_user()
                        elsif input == "unfollow" || input == 'ufo'
                                unfollow_user()
                        elsif input == "delete" || input == 'd'
                                delete_post()
                        elsif input == "help" || input == '?'
                                help()
                        elsif input == "quit" || input == 'q'
                                quit = true
                        else
                                puts "Unrecognized command."
                        end
                        sleep(0.1)
                end
        end
end

session = Twitter.new("access")

session.begin
