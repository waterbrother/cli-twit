#!/usr/bin/ruby

require 'rubygems'
require 'oauth'
require 'json'
require 'net/http'
require 'rake'
require 'io/console'
require 'curses'

class Twitter
        def initialize(accessfile)
                @accessfile = accessfile
        end

        def datafile_exists
                return File.exists?(@accessfile)
        end

        def get_consumer
                data = Net::HTTP.get( 'julianrutledge.com', '/cli-twit' )
                data_hash = data.split(":")
                @consumer_key = data_hash[0].chomp
                #puts "ck: " + @consumer_key
                @consumer_secret = data_hash[1].chomp
                #puts "ck: " + @consumer_secret
        end


        def authorize
                @consumer = OAuth::Consumer.new(
                        @consumer_key,
                        @consumer_secret,
                        {
                                :site => "https://api.twitter.com",
                                :scheme => :header,
                                :http_method =>:post,
                                :request_token_path => "/oauth/request_token",
                                :access_token_path => "/oauth/access_token",
                                :authorize_path => "/oauth/authorize"
                        }
                )
                @request_token = @consumer.get_request_token

                puts "Please visit the following URL: "
                puts @request_token.authorize_url
                puts "to authorize cli-twit to post on your behalf."
                puts "Enter the authorization PIN to continue, or 'q' to quit:"
                input = gets.chomp
                got_input = false
                if input.downcase == 'q'
                        puts "Exiting without authorizing cli-twit."
                else
                        @access_token = @request_token.get_access_token(
                                :oauth_verifier => input
                        )
                end
        end

        def create_new_datafile
                puts "Welcome to CLI Twit!"
                puts "It seems to be your first time using the software. Let's get set up."
                
                get_consumer()
                authorize()

                File.open("access", "w") { 
                        |line| line.write(@access_token.token + ":" + @access_token.secret) 
                }
        end

        def read_datafile
                access = File.open(@accessfile, "r") 
                access_hash = Hash.new
                access.each { |line| access_hash = line.split(":") }
                access.close
                @token = access_hash[0].chomp
                @secret = access_hash[1].chomp
        end

        def cat_data
                puts @token
                puts @secret
        end

        def get_all_credentials
                get_consumer()  # get the consumer credentials from home
                @api = OAuth::Consumer.new(@consumer_key, @consumer_secret)
                read_datafile() # read the access token from local file
                @access = OAuth::Token.new(@token, @secret)
        end

        def feed_pretty( feed_hash )
                bar = "------------------------------------------------------------------\n"
		pretty_output = ""
                feed_hash.each { |tweet| # include tweet_id for replies
                        #make this a bit more readable
                        user = tweet[1][0]
                        #remove trailing hyperlink
                        text_array = tweet[1][1].split("http")
                        text = text_array[0].sub("\n"," ")
                        #remove newlines
                        text = text.sub("\n"," ")
                        #remove carriage returns
                        text = text.sub("\r"," ")
                        #remove ampersands
                        text = text.sub("&amp;","&")
                        #remove "greater than"
                        text = text.sub("&gt;",">")
                        #remove "less than"
                        text = text.sub("&lt;","<")

                        tweet_id = tweet[1][2]
                        link_hash = tweet[1][3]
                        screen_name = tweet[1][4]
                        num_favs = tweet[1][5]
                        num_retw = tweet[1][6]
                        date = tweet[1][7]

                        #count the username and create the tabspace until the text
                        pretty_output << "    #{user} @#{screen_name}\n"
                        pretty_output << "    " + text
                        pretty_output << "\n"
                        #dealing with PITA urls
                        if link_hash != nil
                                link = link_hash["expanded_url"]
                                if link.length > 50
                                        link = link_hash["url"]
                                        pretty_output << "    link: #{link}\n"
                                else
                                        pretty_output << "    link: #{link}\n"
                                end
                        elsif "#{text_array[1]}".length > 1
                                pretty_output << "    link: http#{text_array[1]}\n"
                        end
			pretty_output << "    .........................\n"
                        pretty_output << "    tweet id: #{tweet_id}\n"
                        pretty_output << "    retweets: #{num_retw}\n"
                        pretty_output << "    favorites: #{num_favs}\n"
                        pretty_output << "    date posted: #{date}\n"
                        pretty_output << bar
                }
		return pretty_output
        end

        def api_call(http_method, api_path, query_opts)
                #using a query here is a more uniform method than request.set_form_data for POST
                if query_opts != nil
                        query = URI.encode_www_form(query_opts)
                        @query = "?#{query}"
                else
                        @query = ""
                end

                @base_url = "https://api.twitter.com"
                @path = api_path
                @address = URI("#{@base_url}#{@path}#{@query}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                if http_method == :get
                        @request = Net::HTTP::Get.new(@address.request_uri)
                elsif http_method == :post
                        @request = Net::HTTP::Post.new(@address.request_uri)
                end
                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)
        end

        def favorite(favorite_id)
                output = ""

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/create.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output =  "Tweet has been favorited: #{tweet["text"]}\n"
                        else
                                output =  "Tweet failed to be favorited: #{@response.body}"
                        end
                else
                        output = "Please pass tweet id as an argument to this function.\n"
                end

                return output
        end

        def unfavorite(favorite_id)
                output = ""

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/destroy.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output = "Tweet has been unfavorited: #{tweet["text"]}\n"
                        else
                                output = "Tweet failed to be unfavorited: #{@response.body}\n"
                        end
                else
                        output = "Please pass tweet id as an argument to this function.\n"
                end

                return output
        end

 
        def get_home_timeline(rows)
		#minus 11 for the head
		#divided by 10 lines per tweet
		max_tweets = ( (rows - 11).to_f/10 ).floor
                api_call( :get, "/1.1/statuses/home_timeline.json", {"count" => max_tweets} )

                feed = nil
                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        #puts feed
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date ]
                                count += 1
                        }

                        #puts output

                        #make our output prettier
                        return feed_pretty(output)
                else
                        return "Could not get the feed! Code:#{@response.code} Body:#{@response.body}"
                end
        end

        def post_tweet(text)
                output = ""

                if text != nil and text.length > 140
                        output = "Tweet text is more than 140 characters. Post aborted.\n"
                elsif text != nil and text.length <= 140
                        api_call( :post, "/1.1/statuses/update.json", {"status" => text} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output = "Tweet has been posted: #{tweet["text"]}\n"
                        else
                                output = "Tweet failed to post: #{@response.body}\n"
                        end
                else
                        output = "No tweet text given. Post aborted.\n"
                end

                return output
        end

        def post_reply(username, tweet_id, text)
                output = ""

                all_good = true if username != nil and tweet_id != nil and text != nil and username =~ /@/

                if all_good == true
                        tweet_length = username.length + text.length
                        
                        if tweet_length > 140
                                output = "Tweet length more than 140 characters. Reply aborted.\n"
                        else
                                final_text = "#{username} #{text}"
                                api_call( :post, "/1.1/statuses/update.json", {"status" => final_text, "in_reply_to_status_id" => tweet_id} )
                                
                                if @response.code == '200'
                                        tweet = JSON.parse(@response.body)
                                        output =  "Tweet has been posted: #{tweet["text"]}\n"
                                else
                                        output << "Tweet failed to post: #{@response.body}\n"
                                end
                        end
                else
                        output = "Please check your parameters. See help function for more info.\n"
                end

                return output
        end

        def retweet(tweet_id)
                output = ""

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/retweet/#{tweet_id}.json", {} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output = "Tweet has been posted: #{tweet["text"]}\n"
                        else
                                output << "Tweet failed to post: #{@response.body}\n"
                        end
                else
                        output = "Tweet id empty. Retweeting aborted.\n"
                end

                return output
        end

        def delete_post(tweet_id)
                output = ""

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/destroy.json", {"id" => tweet_id} )
                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output = "Tweet ##{tweet["id_str"]} has been deleted: #{tweet["text"]}\n"
                        else
                                output = "Tweet failed to delete: #{@response.body}\n"
                        end
                else
                        output = "No tweet ID given; deletion aborted.\n"
                end

                return output
        end

        def follow_user(username)
                output = ""

                if username != nil
                        api_call( :post, "/1.1/friendships/create.json", { "screen_name" => username, "follow" => true } )
                        if @response.code == '200'
                                confirm = JSON.parse(@response.body)
                                user_followed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output = "Now following user #{user_followed}: #{real_name}\n"
                        else
                                output = "Failed to follow user: #{@response.body}\n"
                        end
                else
                        output = "Follow failed; username cannot be empty.\n"
                end

                return output
        end

        def unfollow_user(username)
                output = ""

                if username != nil
                        api_call( :post, "/1.1/friendships/destroy.json", { "screen_name" => username })
                        if @response.code == '200' then
                                confirm = JSON.parse(@response.body)
                                user_unfollowed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output =  "Unfollowed user #{user_unfollowed}: #{real_name}"
                        else
                                output = "Failed to follow user: #{@response.body}"
                        end
                else
                        output = "Unfollow failed; username cannot be empty.\n"
                end

                return output
         end

         def get_user_feed(username, rows)
		#minus 11 for the head
		#divided by 10 lines per tweet
		max_tweets = ( (rows - 11).to_f/10 ).floor
                api_call( :get, "/1.1/statuses/user_timeline.json", {"screen_name" => username, "count" => max_tweets })

                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty(output)
               else
                        return "Could not get the feed!" +
                        "Code:#{@response.code} Body:#{@response.body}"
               end
        end

        def header
                header = []
                header << "       ________   ____      ___      __________ "
                header << "      /       /  /   /     /   /    /         /           __"
                header << "     /   ____/  /   /     /   /    /___   ___/           /_/   __"
                header << "    /   /      /   /     /   / ____   /  /   __     __  _   __/ /_"
                header << "   /   /      /   /     /   / /___/  /  /   / / _  / / / / /_  __/"
                header << "  /   /____  /   /___  /   /        /  /   / / // / / / /   / /"
                header << " /        / /       / /   /        /  /   / /_//_/ / / /   / /"
                header << "/________/ /_______/ /___/        /__/   /________/ /_/   /_/"

                return header
        end

        def print_bar(num)
                bar = ""
                num.times { bar << "-" }
                return bar
        end

        def help
                help = []
                help << "Command syntax:\n"
                help << "  <command>: <parameter1>,<parameter2>,<etc...>\n"
                help << "\n"
                help << "Command List:\n"
                help << "  'home' or 'h':\n"
                help << "      View your home feed\n"
                help << "      home\n"
                help << "  'post' or 'p':\n"
                help << "      Write a post\n"
                help << "      post: <tweet_text>\n"
                help << "  'reply' or 'rp':\n"
                help << "      Reply to a tweet\n"
                help << "      reply: <username>,<tweet_id>,<reply_text>\n"
                help << "  'retweet' or 'rt':\n"
                help << "      Retweet a tweet\n"
                help << "      retweet: <tweet_id>\n"
                help << "  'user' or 'u':\n"
                help << "      View another user's feed\n"
                help << "      user: <username>\n"
                help << "  'fav' or 'f':\n"
                help << "      Mark a post as favorite\n"
                help << "      fav: <tweet_id>\n"
                help << "  'unfav' or 'uf':\n"
                help << "      Unmark a post as favorite\n"
                help << "      unfav: <tweet_id>\n"
                help << "  'follow' or 'fo':\n"
                help << "      Follow a user's tweets\n"
                help << "      follow: <username>\n"
                help << "  'unfolow' or 'ufo':\n"
                help << "      Unfollow a user's tweets\n"
                help << "      unfollow: <username>\n"
                help << "  'delete' or 'd':\n"
                help << "      Delete one of your posts (must be your own)\n"
                help << "      delete: <tweet_id>\n"
                help << "  'help' or '?':\n"
                help << "      View this menu\n"
                help << "      help\n"
                help << "  'quit' or 'q':\n"
                help << "      Exit the program\n"
                help << "      quit\n"
                return help
        end

	def center_pos(rows,columns)
		row_center = (rows.to_f/2).floor
		col_center = (columns.to_f/2).floor
		return row_center, col_center
	end

	def output(input)
                #output = Curses::Window.new
	end

        def process_command( command,r,c )
                case command
                        when command =~ /^home:/ || command =~ /^h:/
                                timeline = get_home_timeline(r)
				output( timeline )
                        when command =~ /^post:/ || command =~ /^p:/
                                post = command.split(": ")[1]
                                output( post_tweet(post) )
                        when command =~ /^reply:/ || command =~ /^rp:/
                                reply = command.split(": ")[1]
                                name = reply.split(",")[0]
                                id = reply.split(",")[1]
                                text = reply.split(",")[2..-1].join(",")
                                reply_output = post_reply(name, id, text)
                                output ( reply_output )
                        when command =~ /^retweet:/ || command =~ /^rt:/
                                id = command.split(": ")[1]
                                output( retweet(id) )
                        when command =~ /^user:/ || command =~ /^u:/
                                user = command.split(": ")[1]
                                user_feed = get_user_feed(user, r)
                                output ( user_feed )
                        when command =~ /^fav:/ || command =~ /^f:/
                                id = command.split(": ")[1]
                                output( favorite(id) )
                        when command =~ /^unfav:/ || command =~ /^uf:/
                                id = command.split(": ")[1]
                                output( unfavorite(id) )
                        when command =~ /^follow:/ || command =~ /^fo:/
                                user = command.split(": ")[1]
                                output( follow_user(user) )
                        when command=~ /^unfollow:/ || command =~ /^ufo:/
                                user = command.split(": ")[1]
                                output( unfollow_user(user) )
                        when command =~ /^delete:/ || command =~ /^d:/
                                post = command.split(": ")[1]
                                output( delete_post(post) )
                        when command =~ /^help$/ || command =~ /^?$/
                                output( help() )
                        when command =~ /^quit$/ || command =~ /^q$/
				exit
                        else
                                if command == ""
                                        output("Please enter a command:\n")
                                else
                                        output( "Unrecognized command.\n" )
                                end
                        end
        end
        
	def get_command(r, c)
                getcom = Curses::Window.new(r,c,0,0)
                getcom.box('|','-','#')
                getcom.setpos( (r - 2),1 )

                #declare line incrementor for output
                i = 1 

                #draw the cli-twit header
                head = header()
                head.each do |line|
                        getcom.setpos(i,1)
                        getcom.addstr(line)
                        i += 1
                end

                #draw the bar below the header
                getcom.setpos(i,1)
                getcom.addstr( print_bar( c - 2 ) )
                i += 1
                getcom.setpos(i,1)

                getcom.addstr(":")
                Curses.echo
                command = getcom.getstr
                Curses.noecho
                
                process_command( command,r,c )
	end

        def begin
                if datafile_exists() == false
                        create_new_datafile() # both consumer info and access token are gathered in this step
                end

		rows, columns = $stdin.winsize

                if rows > 22 and columns > 66
                        #draw our first window and set echo off
                        Curses.noecho
                        screen = Curses::Window.new(rows,columns,0,0)
                        screen.box('|','-','#')

                        #declare line incrementor for output
                        i = 1 

                        #draw the cli-twit header
                        head = header()
                        head.each do |line|
                                screen.setpos(i,1)
                                screen.addstr(line)
                                i += 1
                        end

                        #draw the bar below the header
                        screen.setpos(i,1)
                        screen.addstr( print_bar( columns - 2 ) )
                        i += 1

                        #prompt for input
                        screen.setpos(i,1)
                        screen.addstr("Press ':' to enter command mode")
                        i+= 1
                        screen.setpos(i,1)

                        loop do 
                                input = screen.getch

                                if input == ':'
                                        screen.close
                                        get_command(rows, columns)
                                        #exit cleanly from this loop
                                        exit
                                end
                        end
		else
			puts `clear`
			puts "The terminal size is too small."
			puts "The terminal must be"
			pust "at least 22 characters tall"
			puts "and 66 characters wide."
			puts "Please resize and run again."
			exit
		end
        end
end

session = Twitter.new("access")

session.begin

