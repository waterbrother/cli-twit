#!/usr/bin/ruby

require 'rubygems'
require 'oauth'
require 'json'
require 'net/http'
require 'rake'
require 'io/console'
require 'curses'

class Twitter
        def initialize(accessfile)
                @accessfile = accessfile
        end

        def datafile_exists
                return File.exists?(@accessfile)
        end

        def get_consumer
                data = Net::HTTP.get( 'julianrutledge.com', '/cli-twit' )
                data_hash = data.split(":")
                @consumer_key = data_hash[0].chomp
                #puts "ck: " + @consumer_key
                @consumer_secret = data_hash[1].chomp
                #puts "ck: " + @consumer_secret
        end


        def authorize
                @consumer = OAuth::Consumer.new(
                        @consumer_key,
                        @consumer_secret,
                        {
                                :site => "https://api.twitter.com",
                                :scheme => :header,
                                :http_method =>:post,
                                :request_token_path => "/oauth/request_token",
                                :access_token_path => "/oauth/access_token",
                                :authorize_path => "/oauth/authorize"
                        }
                )
                @request_token = @consumer.get_request_token

                puts "Please visit the following URL: "
                puts @request_token.authorize_url
                puts "to authorize cli-twit to post on your behalf."
                puts "Enter the authorization PIN to continue, or 'q' to quit:"
                input = gets.chomp
                got_input = false
                if input.downcase == 'q'
                        puts "Exiting without authorizing cli-twit."
                else
                        @access_token = @request_token.get_access_token(
                                :oauth_verifier => input
                        )
                end
        end

        def create_new_datafile
                puts "Welcome to CLI Twit!"
                puts "It seems to be your first time using the software. Let's get set up."
                
                get_consumer()
                authorize()

                File.open("access", "w") { 
                        |line| line.write(@access_token.token + ":" + @access_token.secret) 
                }
        end

        def read_datafile
                access = File.open(@accessfile, "r") 
                access_hash = Hash.new
                access.each { |line| access_hash = line.split(":") }
                access.close
                @token = access_hash[0].chomp
                @secret = access_hash[1].chomp
        end

        def cat_data
                puts @token
                puts @secret
        end

        def get_all_credentials
                get_consumer()  # get the consumer credentials from home
                @api = OAuth::Consumer.new(@consumer_key, @consumer_secret)
                read_datafile() # read the access token from local file
                @access = OAuth::Token.new(@token, @secret)
        end

        def feed_pretty( feed_hash, columns )
                bar = print_bar( columns - 2 )
                #bar = "------------------------------------------------------------------\n"
		pretty_output = []
                feed_hash.each { |tweet| # include tweet_id for replies
                        #make this a bit more readable
                        user = tweet[1][0]
                        #remove trailing hyperlink
                        text_array = tweet[1][1].split("http")
                        text = text_array[0].sub("\n"," ")
                        #remove newlines
                        text = text.sub("\n"," ")
                        #remove carriage returns
                        text = text.sub("\r"," ")
                        #remove ampersands
                        text = text.sub("&amp;","&")
                        #remove "greater than"
                        text = text.sub("&gt;",">")
                        #remove "less than"
                        text = text.sub("&lt;","<")

                        tweet_id = tweet[1][2]
                        link_hash = tweet[1][3]
                        screen_name = tweet[1][4]
                        num_favs = tweet[1][5]
                        num_retw = tweet[1][6]
                        date = tweet[1][7]

                        #count the username and create the tabspace until the text
                        pretty_output << "    #{user} @#{screen_name}"
                        pretty_output << "    " + text
                        pretty_output << ""
                        #dealing with PITA urls
                        if link_hash != nil
                                link = link_hash["expanded_url"]
                                if link.length > 50
                                        link = link_hash["url"]
                                        pretty_output << "    link: #{link}"
                                else
                                        pretty_output << "    link: #{link}"
                                end
                        elsif "#{text_array[1]}".length > 1
                                pretty_output << "    link: http#{text_array[1]}"
                        end
			pretty_output << "    ........................."
                        pretty_output << "    tweet id: #{tweet_id}"
                        pretty_output << "    retweets: #{num_retw}"
                        pretty_output << "    favorites: #{num_favs}"
                        pretty_output << "    date posted: #{date}"
                        pretty_output << bar
                }
		return pretty_output
        end

        def api_call(http_method, api_path, query_opts)
                #using a query here is a more uniform method than request.set_form_data for POST
                if query_opts != nil
                        query = URI.encode_www_form(query_opts)
                        @query = "?#{query}"
                else
                        @query = ""
                end

                @base_url = "https://api.twitter.com"
                @path = api_path
                @address = URI("#{@base_url}#{@path}#{@query}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                if http_method == :get
                        @request = Net::HTTP::Get.new(@address.request_uri)
                elsif http_method == :post
                        @request = Net::HTTP::Post.new(@address.request_uri)
                end
                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)
        end

        def favorite(favorite_id)
                output = []

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/create.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been favorited: #{tweet["text"]}"
                        else
                                output << "Tweet failed to be favorited: #{@response.body}"
                        end
                else
                        output << "Please pass tweet id as an argument to this function."
                end

                return output
        end

        def unfavorite(favorite_id)
                output = []

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/destroy.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been unfavorited: #{tweet["text"]}"
                        else
                                output << "Tweet failed to be unfavorited: #{@response.body}"
                        end
                else
                        output << "Please pass tweet id as an argument to this function."
                end

                return output
        end

 
        def get_home_timeline(rows,columns,num_posts)
		#minus 11 for the head
		#divided by 10 lines per tweet
                #soon this will be replaced by user specification once i figure out how to 
                #make the text scroll in the screen, hence passing the number of posts in the args
		max_tweets = ( (rows - 11).to_f/10 ).floor
                api_call( :get, "/1.1/statuses/home_timeline.json", {"count" => max_tweets} )

                feed = nil
                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        #puts feed
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date ]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty(output, columns)
                else
                        return ["Could not get the feed! Code:#{@response.code} Body:#{@response.body}"]
                end
        end

        def post_tweet(text)
                output = []

                if text != nil and text.length > 140
                        output << "Tweet text is more than 140 characters. Post aborted."
                elsif text != nil and text.length <= 140
                        api_call( :post, "/1.1/statuses/update.json", {"status" => text} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been posted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to post: #{@response.body}"
                        end
                else
                        output << "No tweet text given. Post aborted."
                end

                return output
        end

        def post_reply(username, tweet_id, text)
                output = []

                all_good = true if username != nil and tweet_id != nil and text != nil and username =~ /@/

                if all_good == true
                        tweet_length = username.length + text.length
                        
                        if tweet_length > 140
                                output << "Tweet length more than 140 characters. Reply aborted."
                        else
                                final_text = "#{username} #{text}"
                                api_call( :post, "/1.1/statuses/update.json", {"status" => final_text, "in_reply_to_status_id" => tweet_id} )
                                
                                if @response.code == '200'
                                        tweet = JSON.parse(@response.body)
                                        output <<  "Tweet has been posted: #{tweet["text"]}"
                                else
                                        output << "Tweet failed to post: #{@response.body}"
                                end
                        end
                else
                        output << "Please check your parameters. See help function for more info."
                end

                return output
        end

        def retweet(tweet_id)
                output = []

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/retweet/#{tweet_id}.json", {} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been posted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to post: #{@response.body}"
                        end
                else
                        output << "Tweet id empty. Retweeting aborted."
                end

                return output
        end

        def delete_post(tweet_id)
                output = []

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/destroy.json", {"id" => tweet_id} )
                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet ##{tweet["id_str"]} has been deleted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to delete: #{@response.body}"
                        end
                else
                        output << "No tweet ID given; deletion aborted."
                end

                return output
        end

        def follow_user(username)
                output = []

                if username != nil
                        api_call( :post, "/1.1/friendships/create.json", { "screen_name" => username, "follow" => true } )
                        if @response.code == '200'
                                confirm = JSON.parse(@response.body)
                                user_followed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output << "Now following user #{user_followed}: #{real_name}"
                        else
                                output << "Failed to follow user: #{@response.body}"
                        end
                else
                        output << "Follow failed; username cannot be empty."
                end

                return output
        end

        def unfollow_user(username)
                output = []

                if username != nil
                        api_call( :post, "/1.1/friendships/destroy.json", { "screen_name" => username })
                        if @response.code == '200' then
                                confirm = JSON.parse(@response.body)
                                user_unfollowed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output <<  "Unfollowed user #{user_unfollowed}: #{real_name}"
                        else
                                output << "Failed to follow user: #{@response.body}"
                        end
                else
                        output << "Unfollow failed; username cannot be empty."
                end

                return output
         end

         def get_user_feed(username, rows, columns )
		#minus 11 for the head
		#divided by 10 lines per tweet
		max_tweets = ( (rows - 11).to_f/10 ).floor
                api_call( :get, "/1.1/statuses/user_timeline.json", {"screen_name" => username, "count" => max_tweets })

                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty(output, columns)
               else
                        return "Could not get the feed!" +
                        "Code:#{@response.code} Body:#{@response.body}"
               end
        end

        def header
                header = []
                header << "       ________   ____      ___      __________ "
                header << "      /       /  /   /     /   /    /         /           __"
                header << "     /   ____/  /   /     /   /    /___   ___/           /_/   __"
                header << "    /   /      /   /     /   / ____   /  /   __     __  _   __/ /_"
                header << "   /   /      /   /     /   / /___/  /  /   / / _  / / / / /_  __/"
                header << "  /   /____  /   /___  /   /        /  /   / / // / / / /   / /"
                header << " /        / /       / /   /        /  /   / /_//_/ / / /   / /"
                header << "/________/ /_______/ /___/        /__/   /________/ /_/   /_/"

                return header
        end

        def print_bar(num)
                bar = ""
                num.times { bar << "-" }
                return bar
        end

        def help
                help = []
                help << "Command syntax:"
                help << "  <command>: <parameter1>,<parameter2>,<etc...>"
                help << ""
                help << "Command List:"
                help << "  'home' or 'h':"
                help << "      View your home feed"
                help << "      home"
                help << "  'post' or 'p':"
                help << "      Write a post"
                help << "      post: <tweet_text>"
                help << "  'reply' or 'rp':"
                help << "      Reply to a tweet"
                help << "      reply: <username>,<tweet_id>,<reply_text>"
                help << "  'retweet' or 'rt':"
                help << "      Retweet a tweet"
                help << "      retweet: <tweet_id>"
                help << "  'user' or 'u':"
                help << "      View another user's feed"
                help << "      user: <username>"
                help << "  'fav' or 'f':"
                help << "      Mark a post as favorite"
                help << "      fav: <tweet_id>"
                help << "  'unfav' or 'uf':"
                help << "      Unmark a post as favorite"
                help << "      unfav: <tweet_id>"
                help << "  'follow' or 'fo':"
                help << "      Follow a user's tweets"
                help << "      follow: <username>"
                help << "  'unfolow' or 'ufo':"
                help << "      Unfollow a user's tweets"
                help << "      unfollow: <username>"
                help << "  'delete' or 'd':"
                help << "      Delete one of your posts (must be your own)"
                help << "      delete: <tweet_id>"
                help << "  'help' or '?':"
                help << "      View this menu"
                help << "      help"
                help << "  'quit' or 'q':"
                help << "      Exit the program"
                help << "      quit"
                return help
        end

	def center_pos(rows,columns)
		row_center = (rows.to_f/2).floor
		col_center = (columns.to_f/2).floor
		return row_center, col_center
	end

	def output(input, rows, columns)
                #draw our first window and set echo off
                Curses.noecho
                screen = Curses::Window.new(rows,columns,0,0)
                screen.box('|','-','#')

                #declare line incrementor for output
                i = 1 

                #draw the cli-twit header
                head = header()
                head.each do |line|
                        screen.setpos(i,1)
                        screen.addstr(line)
                        i += 1
                end

                #draw the bar below the header
                screen.setpos(i,1)
                screen.addstr( print_bar( columns - 2 ) )
                i += 1

                #display text output
                screen.setpos(i,1)
                input.each do |line|
                        screen.setpos(i,1)
                        screen.addstr(line)
                        i += 1
                end
                screen.setpos(i,1)

                #read input
                loop do 
                        input = screen.getch

                        if input == ':'
                                screen.close
                                get_command(rows, columns)
                                #exit cleanly from this loop
                                exit
                        end
                end
        end

        def process_command( command,param,r,c )
                #output command expects an array
                #declare it here so we can get it later
                text_output = Array.new

                #maybe we shuold sanitize our parameter first before blindly passing it to the following functions
                #:: code goes here
                
                case command
                when /^home/, /^h/
                        #set default number if none given
                        param = 10 if param == nil
                        param = 10 if param == 0
                        text_output = get_home_timeline(r,c,param)
                when /^post:/, /^p:/
                        text_output = post_tweet(param)
                when /^reply:/, /^rp:/
                        name = param.split(",")[0]
                        id = param.split(",")[1]
                        text = param.split(",")[2..-1].join(",")#a little extra magic to allow for commas in the text
                        text_output = post_reply(name, id, text)
                when /^retweet:/, /^rt:/
                        text_output = retweet(param)
                when /^user:/, /^u:/
                        text_output = get_user_feed(param, r, c)
                when /^fav:/, /^f:/
                        text_output =  favorite(param)
                when /^unfav:/, /^uf:/
                        text_output = unfavorite(param)
                when /^follow:/, /^fo:/
                        text_output = follow_user(param)
                when /unfollow:/, /^ufo:/
                        text_output( unfollow_user(user), r, c )
                when /^delete:/, /^d:/
                        text_output = delete_post(param)
                when/^help$/, /^\?$/
                        text_output = help()
                when /^quit$/, /^q$/
			exit
                else
                        text_output = ["Unrecognized command: \'#{command}\'"]
                end

                #pull the trigger
                output( text_output, r, c )
        end
        
	def get_command(r, c)
                getcom = Curses::Window.new(r,c,0,0)
                getcom.box('|','-','#')
                getcom.setpos( (r - 2),1 )

                #declare line incrementor for output
                i = 1 

                #draw the cli-twit header
                head = header()
                head.each do |line|
                        getcom.setpos(i,1)
                        getcom.addstr(line)
                        i += 1
                end

                #draw the bar below the header
                getcom.setpos(i,1)
                getcom.addstr( print_bar( c - 2 ) )
                i += 1
                getcom.setpos(i,1)

                getcom.addstr(":")
                Curses.echo
                command = getcom.getstr
                param = command.split(": ")[1]
                Curses.noecho
                
                process_command( command,param,r,c )
	end

        def begin
                if datafile_exists() == false
                        create_new_datafile() # both consumer info and access token are gathered in this step
                end

		rows, columns = $stdin.winsize

                if rows > 22 and columns > 66
                        output(["Press ':' to enter a command"], rows, columns)
		else
			puts `clear`
			puts "The terminal size is too small."
			puts "The terminal must be"
			pust "at least 22 characters tall"
			puts "and 66 characters wide."
			puts "Please resize and run again."
			exit
		end
        end
end

session = Twitter.new("access")

session.begin

