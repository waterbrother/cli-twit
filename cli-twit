#!/usr/bin/ruby
################################################################################
# TODO
# 1. get notifications bar to work:
#    notify about direct messages, favorites, follow requests
#       -direct messages chould be checked once at the initial run-time
#        and then every time the screen is loaded. the number of messages
#        displayed in the bar should reflect the number of unread messages.
#        
# 2. create interface for:
#       -direct messages
#       -follow requests
#       -notifications
#
# 3. navigation: 
#       -include 'h' and 'l' commands to scroll left and right - well, maybe. 
#        is this really usefull? YES - if we truncate text instead of wrapping
#       -recognize key for exiting command bar:
#               -BKSPC until all entered text is gone or 
#               -use STDIN.getc or STDIN.read(num) because Curses fails to see ESC
#
#       -Allow returning to a screen without having to acquire new data or 
#        losing one's place in the output being viewed.
#       -once we can remember current data being shown, move command output to 
#        the command bar. this will be cleared when ':' is pressed. 
#        (maybe 'j' and 'k' too?)
#
################################################################################

require 'rubygems'
require 'oauth'
require 'json'
require 'net/http'
#require 'rake' # I'm not sure we really need rake here. 
require 'io/console'
require 'curses'
require 'optparse'

options = {}
optparse = OptionParser.new do |opts|

        options[:header_size] = nil
        opts.on('-H', '--header <SIZE>', '<large|small|tiny|noascii|3d|none>') do |param|
                options[:header_size] = param
        end

        opts.banner = "Usage:"

        opts.on("-h","--help", "Display help and exit") do 
                puts opts
                exit
        end
end
optparse.parse!

class CLItwit
        def initialize(accessfile, header_size)
                @accessfile = accessfile
                @header_size = header_size
        end

        def datafile_exists
                return File.exists?( @accessfile )
        end

        def get_consumer
                data = Net::HTTP.get( 'julianrutledge.com', '/cli-twit' )
                data_hash = data.split(":")
                @consumer_key = data_hash[0].chomp
                #puts "ck: " + @consumer_key
                @consumer_secret = data_hash[1].chomp
                #puts "ck: " + @consumer_secret
        end


        def authorize
                @consumer = OAuth::Consumer.new(
                        @consumer_key,
                        @consumer_secret,
                        {
                                :site => "https://api.twitter.com",
                                :scheme => :header,
                                :http_method =>:post,
                                :request_token_path => "/oauth/request_token",
                                :access_token_path => "/oauth/access_token",
                                :authorize_path => "/oauth/authorize"
                        }
                )
                @request_token = @consumer.get_request_token

                puts "Please visit the following URL: "
                puts @request_token.authorize_url
                puts "to authorize cli-twit to post on your behalf."
                puts "Enter the authorization PIN to continue, or 'q' to quit:"
                input = gets.chomp
                got_input = false
                if input.downcase == 'q'
                        puts "Exiting without authorizing cli-twit."
                else
                        @access_token = @request_token.get_access_token(
                                :oauth_verifier => input
                        )
                end
        end

        def create_new_datafile
                puts "Welcome to CLI Twit!"
                puts "It seems to be your first time using the software. Let's get set up."
                
                get_consumer()
                authorize()

                File.open( "access", "w" ) { |line| 
                        line.write(@access_token.token + ":" + @access_token.secret) 
                }
        end

        def read_datafile
                access = File.open(@accessfile, "r") 
                access_hash = Hash.new
                access.each { |line| access_hash = line.split(":") }
                access.close
                @token = access_hash[0].chomp
                @secret = access_hash[1].chomp
        end

        def cat_data
                puts @token
                puts @secret
        end

        def get_all_credentials
                get_consumer()  # get the consumer credentials from home
                @api = OAuth::Consumer.new(@consumer_key, @consumer_secret)
                read_datafile() # read the access token from local file
                @access = OAuth::Token.new(@token, @secret)
        end

        def feed_pretty( feed_hash )
                #FEED ME HASH!
                #wait... no.
                #FEED ME _A_ HASH!
                bar = print_bar( @columns - 2, "-" )
		pretty_output = Array.new
                feed_hash.each { |tweet|
                        #make this a bit more readable
                        user = tweet[1][0]
                        #remove  any possible hyperlink at the end of the tweet text
                        #and taking the first element of the array
                        #let's not do this yet. it seems like abad idea.
                        #text_array = tweet[1][1].split("http")
                        text = tweet[1][1]
                        #remove newlines
                        text.gsub!(/\n/," ")
                        #remove carriage returns
                        text.gsub!(/\r/," ")
                        #fix any whitespace characters
                        text.gsub!(/\s/," ")
                        #remove ampersands
                        text.gsub!(/&amp;/,'&')
                        #remove "greater than"
                        text.gsub!(/&gt;/,'>')
                        #remove "less than"
                        text.gsub!(/&lt;/,'<')
                        #fix single quotes
                        text.gsub!(/@~[XY]/,"\'")
                        #remove trailing '@'
                        text.chomp!("@")

                        #include tweet_id for replies
                        tweet_id = tweet[1][2]
                        link_hash = tweet[1][3]
                        screen_name = tweet[1][4]
                        num_favs = tweet[1][5]
                        num_retw = tweet[1][6]
                        date = tweet[1][7]

                        #count the username and create the tabspace until the text
                        pretty_output << "#{user} @#{screen_name}"
                        pretty_output << ""
                        pretty_output << "#{text}"
                        pretty_output << ""

                        #dealing with pain-in-the-ass URLs
                        #if the link hash exists, there are URLs
                        if link_hash != nil
                                link_long = link_hash["expanded_url"]
                                link_short = link_hash["url"]
                                #if the expanded URL is more that 50 char, use the condensed one
                                if link_long.length > 50
                                        pretty_output << "link: #{link_short}"
                                else
                                        pretty_output << "link: #{link_long}"
                                end
                        end
			pretty_output << "........................."
                        pretty_output << "tweet id: #{tweet_id}"
                        pretty_output << "retweets: #{num_retw}  favorites: #{num_favs}"
                        pretty_output << "date posted: #{date}"
                        pretty_output << bar
                }
		return pretty_output
        end

        def api_call( http_method, api_path, query_opts )
                #using a query here is a more uniform method than request.set_form_data for POST
                if query_opts != nil
                        query = URI.encode_www_form(query_opts)
                        @query = "?#{query}"
                else
                        @query = ""
                end

                @base_url = "https://api.twitter.com"
                @path = api_path
                @address = URI("#{@base_url}#{@path}#{@query}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                if http_method == :get
                        @request = Net::HTTP::Get.new(@address.request_uri)
                elsif http_method == :post
                        @request = Net::HTTP::Post.new(@address.request_uri)
                end
                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)
        end

        def favorite( favorite_id )
                output = []

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/create.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been favorited: #{tweet["text"]}"
                        else
                                output << "Tweet failed to be favorited: #{@response.body}"
                        end
                else
                        output << "Please pass tweet id as an argument to this function."
                end

                return output
        end

        def unfavorite( favorite_id )
                output = []

                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/destroy.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been unfavorited: #{tweet["text"]}"
                        else
                                output << "Tweet failed to be unfavorited: #{@response.body}"
                        end
                else
                        output << "Please pass tweet id as an argument to this function."
                end

                return output
        end

 
        def get_home_timeline( num_tweets )
                api_call( :get, "/1.1/statuses/home_timeline.json", {"count" => num_tweets} )

                feed = nil
                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        #puts feed
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date ]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty( output )
                else
                        return ["Could not get the feed! Code:#{@response.code} Body:#{@response.body}"]
                end
        end

        def post_tweet( text )
                output = []

                if text != nil and text.length > 140
                        output << "Tweet text is more than 140 characters. Post aborted."
                elsif text != nil and text.length <= 140
                        api_call( :post, "/1.1/statuses/update.json", {"status" => text} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been posted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to post: #{@response.body}"
                        end
                else
                        output << "No tweet text given. Post aborted."
                end

                return output
        end

        def post_reply( username, tweet_id, text )
                output = []

                all_good = true if username != nil and tweet_id != nil and text != nil and username =~ /@/

                if all_good == true
                        tweet_length = username.length + text.length
                        
                        if tweet_length > 140
                                output << "Tweet length more than 140 characters. Reply aborted."
                        else
                                final_text = "#{username} #{text}"
                                api_call( :post, "/1.1/statuses/update.json", {"status" => final_text, "in_reply_to_status_id" => tweet_id} )
                                
                                if @response.code == '200'
                                        tweet = JSON.parse(@response.body)
                                        output <<  "Tweet has been posted: #{tweet["text"]}"
                                else
                                        output << "Tweet failed to post: #{@response.body}"
                                end
                        end
                else
                        output << "Please check your parameters. See help function for more info."
                end

                return output
        end

        def retweet( tweet_id )
                output = []

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/retweet/#{tweet_id}.json", {} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet has been posted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to post: #{@response.body}"
                        end
                else
                        output << "Tweet id empty. Retweeting aborted."
                end

                return output
        end

        def delete_post( tweet_id )
                output = []

                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/destroy.json", { "id" => tweet_id } )
                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                output << "Tweet ##{tweet["id_str"]} has been deleted: #{tweet["text"]}"
                        else
                                output << "Tweet failed to delete: #{@response.body}"
                        end
                else
                        output << "No tweet ID given; deletion aborted."
                end

                return output
        end

        def follow_user( username )
                output = []

                if username != nil
                        api_call( :post, "/1.1/friendships/create.json", { "screen_name" => username, "follow" => true } )
                        if @response.code == '200'
                                confirm = JSON.parse(@response.body)
                                user_followed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output << "Now following user #{user_followed}: #{real_name}"
                        else
                                output << "Failed to follow user: #{@response.body}"
                        end
                else
                        output << "Follow failed; username cannot be empty."
                end

                return output
        end

        def unfollow_user( username )
                output = []

                if username != nil
                        api_call( :post, "/1.1/friendships/destroy.json", { "screen_name" => username } )
                        if @response.code == '200' then
                                confirm = JSON.parse(@response.body)
                                user_unfollowed = confirm["screen_name"]
                                real_name = confirm["name"]
                                output <<  "Unfollowed user #{user_unfollowed}: #{real_name}"
                        else
                                output << "Failed to follow user: #{@response.body}"
                        end
                else
                        output << "Unfollow failed; username cannot be empty."
                end

                return output
         end

         def get_user_feed( username, num_tweets )
                api_call( :get, "/1.1/statuses/user_timeline.json", { "screen_name" => username, "count" => num_tweets } )

                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty( output )
               else
                        return "Could not get the feed!" +
                        "Code:#{@response.code} Body:#{@response.body}"
               end
        end

        def header(type)
                header_large = []
                header_large << "       ________   ____      ___      __________ "
                header_large << "      /       /  /   /     /   /    /         /           __"
                header_large << "     /   ____/  /   /     /   /    /___   ___/           /_/   __"
                header_large << "    /   /      /   /     /   / ____   /  /   __     __  _   __/ /_"
                header_large << "   /   /      /   /     /   / /___/  /  /   / / _  / / / / /_  __/"
                header_large << "  /   /____  /   /___  /   /        /  /   / / // / / / /   / /"
                header_large << " /        / /       / /   /        /  /   / /_//_/ / / /   / /"
                header_large << "/________/ /_______/ /___/        /__/   /________/ /_/   /_/"

                header_small = []
                header_small << " ____   _     _          _                  _"
                header_small << "|  __| | |   | |  __   _| |_  _  _  _  _  _| |_"
                header_small << "| |__  | |__ | | |__| |_   _|| || || || ||_   _|"
                header_small << "|____| |____||_|        |_|  |_______||_|  |_|"


                header_tiny = []
                header_tiny << " ___ .    .     ___          "
                header_tiny << "|    |    |  -   |  . . . * _|_"
                header_tiny << "|___ |__  |      |  |_|_| |  |"

                header_noascii = [ "CLI-Twit" ]

                header_3d = []
                header_3d << '     ___        ___    ___             ___                                 '
                header_3d << '    /\  \      /\__\  /\  \           /\  \      ___          ___     ___  '
                header_3d << '   /  \  \    / /  /  \ \  \          \ \  \    /\__\        /\__\ _ /\__\ '
                header_3d << '  / /\ \  \  / /  /__  \ \  \   ___    \ \  \  / / _/_      _\/__//\/ /  / '
                header_3d << ' / /  \ \  \/ /  /\  \ /  \  \ /\  \   /  \  \/ / /\__\    /\__\  \  /__/  '
                header_3d << '/ /__/ \ \__\/__/\ \  / /\ \  \\\ \  \ / /\ \  \/_/ / __\  / /  /  /  \__\  '
                header_3d << '\ \  \  \/__/\  \ \ \/ / /\ \__\\\ \__\ /  \ \__\/ / /\__\/ /  /  / /\/__/  '
                header_3d << ' \ \  \     \ \  \ \  /_/  \/__/ \/__//  / \/__/ / / /  / /  /  / /  /     '
                header_3d << '  \ \  \     \ \  \ \ \  \         / /  /      \ \/ /  / /  /  / /  /      '
                header_3d << '   \ \__\     \ \__\ \ \__\       / /  /        \  /  /\/__/   \/__/       '
                header_3d << '    \/__/      \/__/  \/__/       \/__/          \/__/                     '

                header_none = []

                header = case type
                         when "large" then header_large
                         when "small" then header_small
                         when "tiny" then header_tiny
                         when "noascii" then header_noascii
                         when "3d" then header_3d
                         when "none" then header_none
                         else header_3d
                         end

                return header
        end

        def print_bar( num, type )
                bar = ""
                num.times { bar << type }
                return bar
        end

        def help
                help = []
                help << "Navigation:"
                help << "  Use the 'j' and 'k' keys to scroll down and up respectively."
                help << ""
                help << "  When there is additional text available beyond the scope"
                help << "  of the terminal, the bar along the edge of the output"
                help << "  will change from a row of dashes to a row of plusses."
                help << ""
                help << ""
                help << "Command syntax:"
                help << "  <command> <parameter1> <parameter2> <etc...>"
                help << "  Parameters marked |M| are mandatory;"
                help << "  parameters marked |O| are optional."
                help << ""
                help << ""
                help << "Command List:"
                help << "  'home' or 'h'\tView your home feed"
                help << "\t\t\t<command> <|O|number>"
                help << ""
                help << "  'post' or 'p'\tWrite a post"
                help << "\t\t\t<command> <|M|text>"
                help << ""
                help << "  'reply' or 'rp'\tReply to a tweet"
                help << "\t\t\t<command> @<|M|username> <|M|tweet_id> <|M|text>"
                help << ""
                help << "  'retweet' or 'rt'\tRetweet a tweet"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'user' or 'u'\tView another user's feed"
                help << "\t\t\t<command> <|M|username> <|O|number>"
                help << ""
                help << "  'fav' or 'f'   \tMark a post as favorite"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'unfav' or 'uf'\tUnmark a post as favorite"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'follow' or 'fo'\tFollow a user"
                help << "\t\t\t<command> @<|M|username>"
                help << ""
                help << "  'unfolow' or 'ufo'\tUnfollow a user"
                help << "\t\t\t<command> @<|M|username>"
                help << ""
                help << "  'delete' or 'd'\tDelete a tweet (must be your own)"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'help' or '?'\tView this help menu"
                help << ""
                help << "  'quit' or 'q'\tExit the program"
                help << ""
                return help
        end

	def center_pos(rows,columns)
		row_center = (rows.to_f/2).floor
		col_center = (columns.to_f/2).floor
		return row_center, col_center
	end

	def draw_window
                #######################################
                #    I AM THE MASTER OUTPUT METHOD!   #
                #  NO ONE SHOULD DRAW WINDOWS BUT ME  #
                #######################################

                #determine screen size here.
                #this is the first, last, and only place this will be decided.
                #if the user resizes the terminal after this,
                #it will fuck everything up.
		@rows, @columns = $stdin.winsize
                
                #draw our window and set echo off
                #all other methods will clear and redraw this window
                Curses.noecho
                
                #enable keypad - necessary for pageup/pagedown & direction buttons
                Curses.stdscr.keypad( true )
                @screen = Curses::Window.new(@rows,@columns,0,0)
                @screen.box('|','-','#')
        end

        def populate_window( input )
                ################################################################
                #  I AM THE METHOD THAT POPULATES THE MASTER WINDOW WITH DATA  #
                #               I CLEAR THE MASTER AND WRITE OUTPUT            #
                ################################################################

                #clear anything that was written to the screen before this
                @screen.clear

                #declare line incrementor for output
                @i = 1

                ##########
                # HEADER #
                ##########
                
                #draw the cli-twit header
                head = header(@header_size)
                head.each do |line|
                        @screen.setpos(@i,1)
                        @screen.addstr( line )
                        @i += 1
                end

                #################
                # NOTIFICATIONS #
                #################
                
                #draw the bar
                @screen.setpos(@i,1)
                bar_length = @columns - 2
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i += 1
                #TODO: make status bar here for private messages and notifications
                @screen.setpos(@i,1)
                notifications = 0
                messages = 0
                follows = 0
                @screen.addstr( "[#{notifications}] Notifications  [#{messages}] Messages  [#{follows}] Follow Requests" )
                @i += 1
                @screen.setpos(@i,1)
                #the bottom of the notification bar will be drawn as the top of the info panel

                #####################
                # INFORMATION PANEL #
                #####################
                
                #set the max amount of rows of information allowed
                #in the window based on number of rows in the terminal,
                #header hight, the notification bar, and the space needed
                #at the bottom for command entry.
                #defining this here will allow us to scroll through the 
                #info panel with the arrow keys later
                header_size = head.length
                notification_bar_size = 3
                command_bar_size  = 3
                @info_panel_size = @rows - header_size - notification_bar_size - command_bar_size - 1
                #i don't know why this needs an extra row removed, but fuck it - it works

                #draw the bar again and make it change depending on whether the input continues beyond the bar
                if @text_begin > 0
                        @screen.addstr( print_bar( bar_length, "+" ) )
                else
                        @screen.addstr( print_bar( bar_length, "-" ) )
                end
                @i += 1
                #if the input has fewer rows than the info panel, and blank rows to fill the panel
                if input.length < @info_panel_size
                        num_blank_rows = @info_panel_size - input.length
                        num_blank_rows.times do
                                input << ""
                        end
                #if the amount of input is greater than the info panel size, chop that shit to fit!
                #considering the input, this is very likely unless the user specifies  a small amount.
                elsif input.length > @info_panel_size
                        input = input[0..( @info_panel_size - 1 )]
                end

                #display text output
                @screen.setpos(@i,1)
                input.each do |line|
                        @screen.setpos(@i,1)
                        @screen.addstr( line )
                        @i += 1
                end
                @screen.setpos(@i,1)

                #################
                # COMMAND PANEL #
                #################

                #draw the bar same as above, change if text continues beyond bar
                if @text_end <= @info_panel_size + @text_begin
                        @screen.addstr( print_bar( bar_length, "-" ) )
                else
                        @screen.addstr( print_bar( bar_length, "+" ) )
                end
                @i += 1
                @screen.setpos(@i,1)
                #this mind intentionally left blank
                @screen.addstr( "" )
                @i += 1
                #draw the bar again
                @screen.setpos(@i,1)
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i -= 1
                @screen.setpos(@i,1)
        end

        def read_input
                loop do 
                        input = @screen.getch

                        case input

                        when ':'
                                get_command()
                        when 'k'
                                scroll_up()
                        when 'j'
                                scroll_down()
                        end
                end
        end

        def scroll_up
                @text_begin -= 1 if @text_begin > 0
                populate_window( @text_output[@text_begin..-1] )
                read_input()
        end

        def scroll_down()
                @text_begin += 1 if @text_begin <= @text_end - @info_panel_size
                populate_window( @text_output[@text_begin..-1] )
                read_input()
        end

        def process_command( command, params )
                #output command expects an array
                #declare it here so we can get it later
                text_output = Array.new

                #maybe we should sanitize our parameter first before blindly passing it to the following functions
                #:: code goes here
                #nah, fuck it.
                
                case command
                when nil
                        #do nothing.
                        #this used to allow us to bail on a command and stay on the same screen. 
                        #that's now done in get_command, but this is still here just to be safe
                when /^home$/, /^h$/
                        tweets = params[0]
                        tweets = 20 if tweets == nil
                        @text_output = get_home_timeline( tweets )
                when /^post$/, /^p$/
                        @text_output = post_tweet( params.join(" ") )
                when /^reply$/, /^rp$/
                        name = params[0]
                        id = params[1]
                        text = params[2..-1].join(" ")
                        @text_output = post_reply( name, id, text )
                when /^retweet$/, /^rt$/
                        @text_output = retweet( params[0] )
                when /^user$/, /^u$/
                        user, tweets = params
                        tweets = 20 if tweets == nil
                        @text_output = get_user_feed( user, tweets )
                when /^fav$/, /^f$/
                        @text_output =  favorite( params[0] )
                when /^unfav$/, /^uf$/
                        @text_output = unfavorite( params[0] )
                when /^follow$/, /^fo$/
                        @text_output = follow_user( params[0] )
                when /unfollow$/, /^ufo$/
                        @text_output = unfollow_user( params[0] )
                when /^delete$/, /^d$/
                        @text_output = delete_post( params[0] )
                when/^help$/, /^\?$/
                        @text_output = help()
                when /^quit$/, /^q$/, /^exit$/
			exit
                else
                        @text_output = [ "Unrecognized command: \'#{command}\'", "For a list of commands, use '?' or 'help'" ]
                end

                #burger's done
                @text_end = @text_output.length
                populate_window( @text_output )
                read_input()
        end
        
	def get_command
                @screen.addstr(":")
                #########################################
                # THE OLD WAY
                #Curses.echo
                #input = @screen.getstr
                #command = input.split(" ")[0]
                #params = input.split(" ")[1..-1]#this returns an array
                #Curses.noecho
                #########################################
                
                #########################################
                # THE NEW WAY
                input = ""
                col_i = 2
                loop do
                        c = @screen.getch
                        case c 
                        when 127
                                # I can has backspace? 
                                if col_i > 2
                                        #move the cursor back
                                        @screen.setpos( @i, col_i - 1 )
                                        #clobber currect char with a space
                                        @screen.addstr(" ")
                                        #remove the last char from the input string
                                        input.chop!
                                        #change cursor reference location
                                        col_i -= 1
                                        #move the cursor to the reference location
                                        @screen.setpos( @i, col_i )
                                elsif col_i <=2
                                        #move the cursor back
                                        @screen.setpos( @i, col_i - 1 )
                                        #clobber currect char with a space
                                        @screen.addstr(" ")
                                        col_i -= 1
                                        #move the cursor to the reference location
                                        @screen.setpos( @i, col_i )
                                        break                                        
                                end
                        when /[0-9]/, /[a-z]/, /[A-Z]/, ' ', /[?]/
                                #using this to sanitize input, only acceptable chars should be here
                                @screen.addstr("#{c}")
                                input << c
                                col_i += 1
                                @screen.setpos( @i, col_i )
                        when 10
                                break
                        else
                                # the trash bin. just put a single place-holder char that can be removed easily
                                # and won't cause any trouble when it's read
                                @screen.addstr("#")
                                input << "#"
                                col_i += 1
                                @screen.setpos( @i, col_i )

                        end
                end
                command = input.split(" ")[0]
                params = input.split(" ")[1..-1]#this returns an array
                #########################################
                
                #reset this every time a new command is issued. 
                @text_begin = 0
                
                #this is where the snake eats its tail:
                #we loop back on ourselves here.
                process_command( command, params ) if command != nil
	end

        def begin
                if datafile_exists() == false
                        create_new_datafile() # both consumer info and access token are gathered in this step
                end


                #check screen size here first before we launch.
                #this will be checks again when the output screen is drawn.
		rows, columns = $stdin.winsize
                if rows > 22 and columns > 66
                        #this is where we draw our screen, draw our screen, draw our screen;
                        #this is where we draw our screen - all day long.
                        draw_window
                        #first data
                        @text_output = [ "Press ':' to enter a command" ]
                        @text_begin = 0
                        @text_end = @text_output.length
                        populate_window( @text_output )
                        read_input()
                        
		else
			puts `clear`
			puts "The terminal size is too small."
			puts "The terminal must be"
			puts "at least 22 characters tall"
			puts "and 66 characters wide."
			puts "Please resize and run again."
			exit
		end
        end
end

session = CLItwit.new( "access", options[:header_size] )
session.begin

