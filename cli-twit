#!/usr/bin/ruby
################################################################################
# TODO
# 1. get notifications bar to work:
#    notify about direct messages, favorites, follow requests
#       -direct messages chould be checked once at the initial run-time
#        and then every time the screen is loaded. the number of messages
#        displayed in the bar should reflect the number of unread messages.
#
#        It may be desireable to write a file that will remember the state
#        of certain things like the most recent message id in the inbox and 
#        number of notifications, etc. This seems unclean to me, but I can't 
#        really imagine any other way to do it. Maybe then it's not worth
#        doing? I have qualms about tracking the user, but the Twitter API
#        doesn't appear to give me a way to find unread messages or new 
#        notifications.
#        
# 2. create interface for:
#       -direct messages
#       -follow requests
#       -notifications
#
# 3. navigation: 
#       -include 'h' and 'l' commands to scroll left and right, and truncate 
#        text that is too long for the output screen instead of wrapping it.
#
#       -create funtion to enforce horizontal character limit and use it on 
#        the main window output as well as the console_comment. this should
#        truncate the output and append a '...' to indicate the truncation
#        occurred 
#
#
#
################################################################################
#
# DONE:
# -Add version display to list of invocation arugments
#
# -Add more usage and navigation info in CLI help output.
#
# -Recognize key for exiting command bar:
#               -BKSPC until all entered text is gone 
#               -use ESC to bail on command mode
#
# -Create new method for clearing the command bar
#
# -Change process_command flow to switch between redrawing the window with new 
#  output or clearing the command bar and writing console comment to command bar
#
# -move output of executed commands to the command bar; output is cleared when
#  the next key event is read. 
#
# -BUGFIX: (minor) bailing out of a command resets the position of the 
#  currently displayed info to the top. 
#
################################################################################

#REQUIREMENTS
require 'oauth'
require 'json'
require 'net/http'
require 'io/console'
require 'curses'
require 'optparse'

#CONSTANTS
VERSION = "CLI-twit v3.8 2016-08-22"
options = {}
optparse = OptionParser.new do |opts|

        options[:header_size] = nil
        opts.on('-H', '--header <SIZE>', '<large|small|tiny|noascii|3d|none>') do |param|
                options[:header_size] = param
        end

        opts.banner = "Navigation:\n" +
                "CLI-Twit navigation uses Vim-like commands.\n" + 
                "    ':'\t\t\t\t     enter command mode\n" + 
                "    'h', 'j', 'k', 'l'\t\t     scroll left, down, up, right \n" + 
                "    please use ':?' to get a list of all commands.\n" + 
                "Invocation:"

        opts.on("-h","--help", "Display help and exit") do 
                puts opts
                exit
        end

        opts.on("-v", "--version", "Display version and exit." ) do 
                puts VERSION
                exit
        end
end
optparse.parse!

class CLItwit
        def initialize(accessfile, header_size)
                @accessfile = accessfile
                @header_size = header_size
        end

        def datafile_exists
                return File.exists?( @accessfile )
        end

        def get_consumer
                data = Net::HTTP.get( 'julianrutledge.com', '/cli-twit' )
                data_hash = data.split(":")
                @consumer_key = data_hash[0].chomp
                #puts "ck: " + @consumer_key
                @consumer_secret = data_hash[1].chomp
                #puts "cs: " + @consumer_secret
        end


        def authorize
                @consumer = OAuth::Consumer.new(
                        @consumer_key,
                        @consumer_secret,
                        {
                                :site => "https://api.twitter.com",
                                :scheme => :header,
                                :http_method =>:post,
                                :request_token_path => "/oauth/request_token",
                                :access_token_path => "/oauth/access_token",
                                :authorize_path => "/oauth/authorize"
                        }
                )
                @request_token = @consumer.get_request_token

                puts "Please visit the following URL: "
                puts @request_token.authorize_url
                puts "to authorize cli-twit to post on your behalf."
                puts "Enter the authorization PIN to continue, or 'q' to quit:"
                input = gets.chomp
                got_input = false
                if input.downcase == 'q'
                        puts "Exiting without authorizing cli-twit."
                else
                        @access_token = @request_token.get_access_token(
                                :oauth_verifier => input
                        )
                end
        end

        def create_new_datafile
                puts "Welcome to CLI Twit!"
                puts "It seems to be your first time using the software. Let's get set up."
                
                get_consumer()
                authorize()

                File.open( "access", "w" ) { |line| 
                        line.write(@access_token.token + ":" + @access_token.secret) 
                }
        end

        def read_datafile
                access = File.open(@accessfile, "r") 
                access_hash = Hash.new
                access.each { |line| access_hash = line.split(":") }
                access.close
                @token = access_hash[0].chomp
                @secret = access_hash[1].chomp
        end

        def cat_data
                puts @token
                puts @secret
        end

        def get_all_credentials
                get_consumer()  # get the consumer credentials from home
                @api = OAuth::Consumer.new(@consumer_key, @consumer_secret)
                read_datafile() # read the access token from local file
                @access = OAuth::Token.new(@token, @secret)
        end

        def feed_pretty( feed_hash )
                #FEED ME HASH!
                #wait... no.
                #FEED ME _A_ HASH!
                bar = print_bar( @columns - 2, "-" )
		pretty_output = Array.new
                feed_hash.each { |tweet|
                        #make this a bit more readable
                        user = tweet[1][0]
                        #remove  any possible hyperlink at the end of the tweet text
                        #and taking the first element of the array
                        #let's not do this yet. it seems like abad idea.
                        #text_array = tweet[1][1].split("http")
                        text = tweet[1][1]
                        #remove newlines
                        text.gsub!(/\n/," ")
                        #remove carriage returns
                        text.gsub!(/\r/," ")
                        #fix any whitespace characters
                        text.gsub!(/\s/," ")
                        #remove ampersands
                        text.gsub!(/&amp;/,'&')
                        #remove "greater than"
                        text.gsub!(/&gt;/,'>')
                        #remove "less than"
                        text.gsub!(/&lt;/,'<')
                        #fix single quotes
                        text.gsub!(/@~[XY]/,"\'")
                        #remove trailing '@'
                        text.chomp!("@")

                        #include tweet_id for replies
                        tweet_id = tweet[1][2]
                        link_hash = tweet[1][3]
                        screen_name = tweet[1][4]
                        num_favs = tweet[1][5]
                        num_retw = tweet[1][6]
                        date = tweet[1][7]

                        #count the username and create the tabspace until the text
                        pretty_output << "#{user} @#{screen_name}"
                        pretty_output << ""
                        pretty_output << "#{text}"
                        pretty_output << ""

                        #dealing with pain-in-the-ass URLs
                        #if the link hash exists, there are URLs
                        if link_hash != nil
                                link_long = link_hash["expanded_url"]
                                link_short = link_hash["url"]
                                #if the expanded URL is more that 50 char, use the condensed one
                                if link_long.length > 50
                                        pretty_output << "link: #{link_short}"
                                else
                                        pretty_output << "link: #{link_long}"
                                end
                        end
			pretty_output << "........................."
                        pretty_output << "tweet id: #{tweet_id}"
                        pretty_output << "retweets: #{num_retw}  favorites: #{num_favs}"
                        pretty_output << "date posted: #{date}"
                        pretty_output << bar
                }
		return pretty_output
        end

        def api_call( http_method, api_path, query_opts )
                #using a query here is a more uniform method than request.set_form_data for POST
                if query_opts != nil
                        query = URI.encode_www_form(query_opts)
                        @query = "?#{query}"
                else
                        @query = ""
                end

                @base_url = "https://api.twitter.com"
                @path = api_path
                @address = URI("#{@base_url}#{@path}#{@query}")

                @twitter = Net::HTTP.new(@address.host, @address.port)
                @twitter.use_ssl = true
                @twitter.verify_mode = OpenSSL::SSL::VERIFY_PEER

                get_all_credentials()

                if http_method == :get
                        @request = Net::HTTP::Get.new(@address.request_uri)
                elsif http_method == :post
                        @request = Net::HTTP::Post.new(@address.request_uri)
                end
                @request.oauth!(@twitter, @api, @access)
                @response = @twitter.request(@request)
        end

        def favorite( favorite_id )
                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/create.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                @console_comment = "Tweet has been favorited: #{tweet["text"]}"
                        else
                                @console_comment = "Tweet failed to be favorited: #{@response.body}"
                        end
                else
                        @console_comment = "Please pass tweet id as an argument to this function."
                end
        end

        def unfavorite( favorite_id )
                if favorite_id != nil
                        api_call( :post, "/1.1/favorites/destroy.json", {"id" => favorite_id} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                @console_comment = "Tweet has been unfavorited: #{tweet["text"]}"
                        else
                                @console_comment = "Tweet failed to be unfavorited: #{@response.body}"
                        end
                else
                        @console_comment = "Please pass tweet id as an argument to this function."
                end
        end

 
        def get_home_timeline( num_tweets )
                api_call( :get, "/1.1/statuses/home_timeline.json", {"count" => num_tweets} )

                feed = nil
                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        #puts feed
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date ]
                                count += 1
                        }

                        #make our output prettier
                        return feed_pretty( output )
                else
                        @console_comment = "Could not get the feed! Code:#{@response.code} Body:#{@response.body}"
                end
        end

        def post_tweet( text )
                if text != nil and text.length > 140
                        @console_comment = "Tweet text is more than 140 characters. Post aborted."
                elsif text != nil and text.length <= 140
                        api_call( :post, "/1.1/statuses/update.json", {"status" => text} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                @console_comment = "Tweet has been posted: #{tweet["text"]}"
                        else
                                @console_comment = "Tweet failed to post: #{@response.body}"
                        end
                else
                        @console_comment = "No tweet text given. Post aborted."
                end
        end

        def post_reply( username, tweet_id, text )

                all_good = true if username != nil and tweet_id != nil and text != nil

                if all_good == true
                        tweet_length = username.length + text.length
                        
                        if tweet_length > 140
                                @console_coment = "Tweet length more than 140 characters. Reply aborted."
                        else
                                final_text = "#{username} #{text}"
                                api_call( :post, "/1.1/statuses/update.json", {"status" => final_text, "in_reply_to_status_id" => tweet_id} )
                                
                                if @response.code == '200'
                                        tweet = JSON.parse(@response.body)
                                        @console_coment = "Tweet has been posted: #{tweet["text"]}"
                                else
                                        @console_coment = "Tweet failed to post: #{@response.body}"
                                end
                        end
                else
                        @console_coment = "Please check your command syntax. See help function for more info."
                end
        end

        def retweet( tweet_id )
                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/retweet/#{tweet_id}.json", {} )

                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                @console_comment = "Tweet has been posted: #{tweet["text"]}"
                        else
                                @console_comment = "Tweet failed to post: #{@response.body}"
                        end
                else
                        @console_comment = "Tweet id empty. Retweeting aborted."
                end
        end

        def delete_post( tweet_id )
                if tweet_id != nil
                        api_call( :post, "/1.1/statuses/destroy.json", { "id" => tweet_id } )
                        if @response.code == '200'
                                tweet = JSON.parse(@response.body)
                                @console_comment = "Tweet ##{tweet["id_str"]} has been deleted: #{tweet["text"]}"
                        else
                                @console_comment = "Tweet failed to delete: #{@response.body}"
                        end
                else
                        @console_comment = "No tweet ID given; deletion aborted."
                end
        end

        def follow_user( username )
                if username != nil
                        api_call( :post, "/1.1/friendships/create.json", { "screen_name" => username, "follow" => true } )
                        if @response.code == '200'
                                confirm = JSON.parse(@response.body)
                                user_followed = confirm["screen_name"]
                                real_name = confirm["name"]
                                @console_comment = "Now following user #{user_followed}: #{real_name}"
                        else
                                @console_comment = "Failed to follow user: #{@response.body}"
                        end
                else
                        @console_comment = "Follow failed; username cannot be empty."
                end
        end

        def unfollow_user( username )
                if username != nil
                        api_call( :post, "/1.1/friendships/destroy.json", { "screen_name" => username } )
                        if @response.code == '200' then
                                confirm = JSON.parse(@response.body)
                                user_unfollowed = confirm["screen_name"]
                                real_name = confirm["name"]
                                @console_comment = "Unfollowed user #{user_unfollowed}: #{real_name}"
                        else
                                @console_comment = "Failed to follow user: #{@response.body}"
                        end
                else
                        @console_comment = "Unfollow failed; username cannot be empty."
                end
         end

         def get_user_feed( username, num_tweets )
                api_call( :get, "/1.1/statuses/user_timeline.json", { "screen_name" => username, "count" => num_tweets } )

                if @response.code == '200' then
                        feed =JSON.parse(@response.body)
                        output = Hash.new
                        count = 0
                        feed.each { |tweet|
                                user = tweet["user"]["name"]
                                screen_name = tweet["user"]["screen_name"]
                                text = tweet["text"]
                                tweet_id = tweet["id"]
                                links = tweet["entities"]["urls"][0]
                                num_favs = tweet["favorite_count"]
                                num_retw = tweet["retweet_count"]
                                date = tweet["created_at"]
                                output[count] = [ user, text, tweet_id, links, screen_name, num_favs, num_retw, date]
                                count += 1
                        }
                        return feed_pretty( output )
               else
                        @console_comment = "Code:#{@response.code} Body:#{@response.body}"
               end
        end

        def header(type)
                header_large = []
                header_large << "       ________   ____      ___      __________ "
                header_large << "      /       /  /   /     /   /    /         /           __"
                header_large << "     /   ____/  /   /     /   /    /___   ___/           /_/   __"
                header_large << "    /   /      /   /     /   / ____   /  /   __     __  _   __/ /_"
                header_large << "   /   /      /   /     /   / /___/  /  /   / / _  / / / / /_  __/"
                header_large << "  /   /____  /   /___  /   /        /  /   / / // / / / /   / /"
                header_large << " /        / /       / /   /        /  /   / /_//_/ / / /   / /"
                header_large << "/________/ /_______/ /___/        /__/   /________/ /_/   /_/"

                header_small = []
                header_small << " ____   _     _          _                  _"
                header_small << "|  __| | |   | |  __   _| |_  _  _  _  _  _| |_"
                header_small << "| |__  | |__ | | |__| |_   _|| || || || ||_   _|"
                header_small << "|____| |____||_|        |_|  |_______||_|  |_|"


                header_tiny = []
                header_tiny << " ___ .    .     ___          "
                header_tiny << "|    |    |  -   |  . . . * _|_"
                header_tiny << "|___ |__  |      |  |_|_| |  |"

                header_noascii = [ "CLI-Twit" ]

                header_3d = []
                header_3d << '     ___        ___    ___             ___                                 '
                header_3d << '    /\  \      /\__\  /\  \           /\  \      ___          ___     ___  '
                header_3d << '   /  \  \    / /  /  \ \  \          \ \  \    /\__\        /\__\ _ /\__\ '
                header_3d << '  / /\ \  \  / /  /__  \ \  \   ___    \ \  \  / / _/_      _\/__//\/ /  / '
                header_3d << ' / /  \ \  \/ /  /\  \ /  \  \ /\  \   /  \  \/ / /\__\    /\__\  \  /__/  '
                header_3d << '/ /__/ \ \__\/__/\ \  / /\ \  \\\ \  \ / /\ \  \/_/ / __\  / /  /  /  \__\  '
                header_3d << '\ \  \  \/__/\  \ \ \/ / /\ \__\\\ \__\ /  \ \__\/ / /\__\/ /  /  / /\/__/  '
                header_3d << ' \ \  \     \ \  \ \  /_/  \/__/ \/__//  / \/__/ / / /  / /  /  / /  /     '
                header_3d << '  \ \  \     \ \  \ \ \  \         / /  /      \ \/ /  / /  /  / /  /      '
                header_3d << '   \ \__\     \ \__\ \ \__\       / /  /        \  /  /\/__/   \/__/       '
                header_3d << '    \/__/      \/__/  \/__/       \/__/          \/__/                     '

                header_none = []

                header = case type
                         when "large" then header_large
                         when "small" then header_small
                         when "tiny" then header_tiny
                         when "noascii" then header_noascii
                         when "3d" then header_3d
                         when "none" then header_none
                         else header_3d
                         end

                return header
        end

        def print_bar( num, type )
                bar = ""
                num.times { bar << type }
                return bar
        end

        def help
                help = []
                help << "Navigation:"
                help << "  Use the 'j' and 'k' keys to scroll down and up respectively."
                help << ""
                help << "  When there is additional text available beyond the scope"
                help << "  of the terminal, the bar along the edge of the output"
                help << "  will change from a row of dashes to a row of plusses."
                help << ""
                help << ""
                help << "Command syntax:"
                help << "  <command> <parameter1> <parameter2> <etc...>"
                help << "  Parameters marked |M| are mandatory;"
                help << "  parameters marked |O| are optional."
                help << ""
                help << ""
                help << "Command List:"
                help << "  'home' or 'h'\tView your home feed"
                help << "\t\t\t<command> <|O|number>"
                help << ""
                help << "  'post' or 'p'\tWrite a post"
                help << "\t\t\t<command> <|M|text>"
                help << ""
                help << "  'reply' or 'rp'\tReply to a tweet"
                help << "\t\t\t<command> @<|M|username> <|M|tweet_id> <|M|text>"
                help << ""
                help << "  'retweet' or 'rt'\tRetweet a tweet"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'user' or 'u'\tView another user's feed"
                help << "\t\t\t<command> <|M|username> <|O|number>"
                help << ""
                help << "  'fav' or 'f'   \tMark a post as favorite"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'unfav' or 'uf'\tUnmark a post as favorite"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'follow' or 'fo'\tFollow a user"
                help << "\t\t\t<command> @<|M|username>"
                help << ""
                help << "  'unfolow' or 'ufo'\tUnfollow a user"
                help << "\t\t\t<command> @<|M|username>"
                help << ""
                help << "  'delete' or 'd'\tDelete a tweet (must be your own)"
                help << "\t\t\t<command> <|M|tweet_id>"
                help << ""
                help << "  'help' or '?'\tView this help menu"
                help << ""
                help << "  'quit' or 'q'\tExit the program"
                help << ""
                return help
        end

	def center_pos(rows,columns)
		row_center = (rows.to_f/2).floor
		col_center = (columns.to_f/2).floor
		return row_center, col_center
	end

	def draw_window
                #######################################
                #    I AM THE MASTER OUTPUT METHOD!   #
                #  NO ONE SHOULD DRAW WINDOWS BUT ME  #
                #######################################

                #determine screen size here.
                #this is the first, last, and only place this will be decided.
                #if the user resizes the terminal after this,
                #it will fuck everything up.
                #2016-08-19: NOT TRUE! the window size is determined in the 'begin'
                #method. I set those to be a class variables instead of re-doing it here. 
		#@rows, @columns = $stdin.winsize
                
                #draw our window and set echo off
                #all other methods will clear and redraw this window
                Curses.noecho
                
                #enable keypad - necessary for pageup/pagedown & direction buttons
                Curses.stdscr.keypad( true )
                @screen = Curses::Window.new(@rows,@columns,0,0)
                @screen.box('|','-','#')
        end

        def populate_window( input )
                ################################################################
                #  I AM THE METHOD THAT POPULATES THE MASTER WINDOW WITH DATA  #
                #               I CLEAR THE MASTER AND WRITE OUTPUT            #
                ################################################################

                #clear anything that was written to the screen before this
                @screen.clear

                #declare line incrementor for output
                @i = 1

                ##########
                # HEADER #
                ##########
                
                #draw the cli-twit header
                head = header(@header_size)
                head.each do |line|
                        @screen.setpos(@i,1)
                        @screen.addstr( line )
                        @i += 1
                end

                #################
                # NOTIFICATIONS #
                #################
                
                #draw the bar
                @screen.setpos(@i,1)
                bar_length = @columns - 2
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i += 1
                #TODO: make status bar here for private messages and notifications
                @screen.setpos(@i,1)
                notifications = 0
                messages = 0
                follows = 0
                @screen.addstr( "[#{notifications}] Notifications  [#{messages}] Messages  [#{follows}] Follow Requests" )
                @i += 1
                @screen.setpos(@i,1)
                #the bottom of the notification bar will be drawn as the top of the info panel

                #####################
                # INFORMATION PANEL #
                #####################
                
                #set the max amount of rows of information allowed
                #in the window based on number of rows in the terminal,
                #header hight, the notification bar, and the space needed
                #at the bottom for command entry.
                #defining this here will allow us to scroll through the 
                #info panel with the arrow keys later
                header_size = head.length
                notification_bar_size = 3
                command_bar_size  = 3
                @info_panel_size = @rows - header_size - notification_bar_size - command_bar_size - 1
                #i don't know why this needs an extra row removed, but fuck it - it works

                #draw the bar again and make it change depending on whether the input continues beyond the bar
                if @text_begin > 0
                        @screen.addstr( print_bar( bar_length, "+" ) )
                else
                        @screen.addstr( print_bar( bar_length, "-" ) )
                end
                @i += 1
                #if the input has fewer rows than the info panel, and blank rows to fill the panel
                if input.length < @info_panel_size
                        num_blank_rows = @info_panel_size - input.length
                        num_blank_rows.times do
                                input << ""
                        end
                #if the amount of input is greater than the info panel size, chop that shit to fit!
                #considering the input, this is very likely unless the user specifies  a small amount.
                elsif input.length > @info_panel_size
                        input = input[0..( @info_panel_size - 1 )]
                end

                #display text output
                @screen.setpos(@i,1)
                input.each do |line|
                        @screen.setpos(@i,1)
                        @screen.addstr( line )
                        @i += 1
                end
                @screen.setpos(@i,1)

                #################
                # COMMAND PANEL #
                #################

                #draw the bar same as above, change if text continues beyond bar
                if @text_end <= @info_panel_size + @text_begin
                        @screen.addstr( print_bar( bar_length, "-" ) )
                else
                        @screen.addstr( print_bar( bar_length, "+" ) )
                end
                @i += 1
                @screen.setpos(@i,1)
                #this mind intentionally left blank
                @screen.addstr( "" )
                @i += 1
                #draw the bar again
                @screen.setpos(@i,1)
                @screen.addstr( print_bar( bar_length, "-" ) )
                @i -= 1
                #specifically remember the number of the line where the cursor should be on the command bar
                @commandbar_row = @i
                #set the cursor position on the command bar
                @screen.setpos(@commandbar_row,1)
        end

        def scroll_up
                #decrement the top line of text if we're not at the first line already
                @text_begin -= 1 if @text_begin > 0
                populate_window( @text_output[@text_begin..-1] )
                read_input()
        end

        def scroll_down()
                #increment the top line of text if the first line is not the last
                @text_begin += 1 if @text_begin <= @text_end - @info_panel_size
                populate_window( @text_output[@text_begin..-1] )
                read_input()
        end

        def clear_commandbar
                #clobber the entire line with empty spaces
                @screen.setpos( @commandbar_row, 1 )
                empty_line = ""
                (@columns - 2 ).times do
                        empty_line << " "
                end
                @screen.addstr("#{empty_line}")
                #set the cursor back to the correct position
                @screen.setpos( @commandbar_row, 1 )
        end
        
        def truncate( string )

        end

        def read_input
                loop do 
                        input = @screen.getch

                        case input

                        when ':'
                                clear_commandbar()
                                get_command()
                        when 'k'
                                scroll_up()
                        when 'j'
                                scroll_down()
                        end
                end
        end

	def get_command
                #allow reading of all characters -particularly the ESC key
                @screen.addstr(":")
                #########################################
                # THE OLD WAY
                #Curses.echo
                #input = @screen.getstr
                #command = input.split(" ")[0]
                #params = input.split(" ")[1..-1]#this returns an array
                #Curses.noecho
                #########################################
                
                #########################################
                # THE NEW WAY
                input = ""
                #hard-code the command bar position on the X axis to initally be set at 2
                col_i = 2
                loop do
                        c = @screen.getch
                        case c 
                        when 127
                                # I can has backspace? 
                                if col_i > 2
                                        #move the cursor back
                                        @screen.setpos( @i, col_i - 1 )
                                        #clobber currect char with a space
                                        @screen.addstr(" ")
                                        #remove the last char from the input string
                                        input.chop!
                                        #change cursor reference location
                                        col_i -= 1
                                        #move the cursor to the reference location
                                        @screen.setpos( @i, col_i )
                                elsif col_i <=2
                                        #move the cursor back
                                        @screen.setpos( @i, col_i - 1 )
                                        #clobber currect char with a space
                                        @screen.addstr(" ")
                                        col_i -= 1
                                        #move the cursor to the reference location
                                        @screen.setpos( @i, col_i )
                                        break                                        
                                end
                        when /[0-9]/, /[a-z]/, /[A-Z]/, ' ', '?', '@'
                                #using this to sanitize input, only acceptable chars should be here
                                @screen.addstr("#{c}")
                                input << c
                                col_i += 1
                                @screen.setpos( @i, col_i )
                        when 10
                                #enter/carriage return - just process the command text
                                #and break from the loop
                                break
                        when 27
                                #ESCAPE IF YOU CAN!
                                clear_commandbar()
                                #empty the command text
                                input = ""
                                #break from the loop
                                break
                        else
                                #the trash bin. just put a single place-holder char that can be removed easily
                                #and won't cause any trouble when it's read
                                @screen.addstr("#")
                                input << "#"
                                col_i += 1
                                @screen.setpos( @i, col_i )

                        end
                end
                command = input.split(" ")[0]
                params = input.split(" ")[1..-1]#this returns an array
                #########################################
                
                #reset this every time a new command is issued unless the input is empty. 
                @text_begin = 0 if input != ""
                
                #this is where the snake eats its tail:
                #we loop back on ourselves here.
                process_command( command, params ) if command != nil
	end

        def process_command( command, params )
                #output command expects an array
                #declare it here so we can get it later
                text_output = Array.new

                #empty any previous console comment
                @console_comment = ""
                case command
                when nil
                        #do nothing.
                        #this used to allow us to bail on a command and stay on the same screen. 
                        #that's now done in get_command, but this is still here just to be safe
                        #and allow for an empty command
                when /^home$/, /^h$/
                        tweets = params[0]
                        tweets = 20 if tweets == nil
                        @text_output = get_home_timeline( tweets )
                when /^post$/, /^p$/
                        @text_output = post_tweet( params.join(" ") )
                when /^reply$/, /^rp$/
                        name = params[0]
                        id = params[1]
                        text = params[2..-1].join(" ")
                        @text_output = post_reply( name, id, text )
                when /^retweet$/, /^rt$/
                        @text_output = retweet( params[0] )
                when /^user$/, /^u$/
                        user, tweets = params
                        tweets = 20 if tweets == nil
                        @text_output = get_user_feed( user, tweets )
                when /^fav$/, /^f$/
                        @text_output =  favorite( params[0] )
                when /^unfav$/, /^uf$/
                        @text_output = unfavorite( params[0] )
                when /^follow$/, /^fo$/
                        @text_output = follow_user( params[0] )
                when /unfollow$/, /^ufo$/
                        @text_output = unfollow_user( params[0] )
                when /^delete$/, /^d$/
                        @text_output = delete_post( params[0] )
                when/^help$/, /^\?$/
                        @text_output = help()
                when /^quit$/, /^q$/, /^exit$/
			exit
                else
                        @console_comment = "Not a command: \'#{command}\'.  For a list of commands, use '?' or 'help'"
                end

                #burger's done
                @text_end = @text_output.length
                if @console_comment.length == 0
                        populate_window( @text_output )
                else
                        clear_commandbar()
                        @screen.addstr( @console_comment )
                end

                read_input()
        end

        def begin
                #create a new datafile if one doesn't exist yet
                #both consumer info and access token are gathered in this step
                create_new_datafile() if datafile_exists() == false

                #check screen size here first before we launch.
                #this will be checks again when the output screen is drawn.
		@rows, @columns = $stdin.winsize
                if @rows > 22 and @columns > 66
                        #this is where we draw our screen, draw our screen, draw our screen;
                        #this is where we draw our screen - all day long.
                        draw_window
                        #first data
                        @text_output = [ "Press ':' to enter a command" ]
                        @text_begin = 0
                        @text_end = @text_output.length
                        populate_window( @text_output )
                        read_input()
                        
		else
			puts `clear`
			puts "The terminal size is too small."
			puts "The terminal must be"
			puts "at least 22 characters tall"
			puts "and 66 characters wide."
			puts "Please resize and run again."
			exit
		end
        end
end

session = CLItwit.new( "access", options[:header_size] )
session.begin

